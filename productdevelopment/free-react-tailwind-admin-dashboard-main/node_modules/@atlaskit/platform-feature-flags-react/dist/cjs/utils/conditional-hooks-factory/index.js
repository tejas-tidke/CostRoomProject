"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache = DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache;
exports.conditionalHooksFactory = conditionalHooksFactory;
// Shorthand alias for the global cache map key because it's (intentionally) a long name
var CACHE_MAP_KEY = '__conditionalHooksFactory_conditionCacheMap_dont_modify_this_manually_unless_you_want_react_to_blow_up';
// Initialize the global cache map once
globalThis[CACHE_MAP_KEY] = globalThis[CACHE_MAP_KEY] || new WeakMap();

/**
 * Resets the cache used by the conditional hooks factory.
 * This is useful for testing purposes or when you want to clear the cache between runs.
 * You should **never** use this in production code as it will break the rules of hooks.
 * Seriously, don't do it.
 *
 * Calling this function will cause all instances of conditional hooks to be re-evaluated
 * and may lead to unexpected behaviour if the conditions change.
 */
function DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache() {
  globalThis[CACHE_MAP_KEY] = new WeakMap();
}

/**
 * A factory function to create a conditional hook. The condition must return a boolean value
 * that does not change after initialisation. This function will cache the result of the condition
 * and use it to determine which hook to call. If the condition changes between renders,
 * unexpected behaviour may occur.
 *
 * The hook generated by this factory will also force the condition to be effectively constant
 * by caching the result of the condition on the first call. In non-production environments,
 * it will throw an error if the condition changes between renders to help catch potential issues.
 *
 * If for some reason you need to reset the cache (i.e. for tests where you change the condition between runs),
 * you can call `DO_NOT_USE_THIS_IN_PRODUCTION_EVER_resetConditionalHooksFactoryCache()`.
 *
 * **This hook should only be used for Feature Gates & Experiments where the value doesn't change.**
 * ```ts
 * // Acceptable use
 * const useMyHook = conditionalHooksFactory(
 *   () => isFeatureEnabled('my-feature'),
 *   useMyNewHook,
 *   useMyOldHook,
 * );
 *
 * // Not acceptable use
 * const useMyHook = conditionalHooksFactory(
 *    () => someVarThatCouldChange === 'my-value',
 *    useMyNewHook,
 *    useMyOldHook,
 * );
 * ```
 *
 * @param condition The condition function that will be used to determine which hook to call.
 * @param newHook The new hook to call if the condition is true.
 * @param oldHook The old hook to call if the condition is false.
 * @returns A migrator hook that will call either the new hook or the old hook based on the condition.
 */
function conditionalHooksFactory(condition, newHook, oldHook) {
  var _hookFn = function hookFn() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    // call each time so we can track exposures
    var conditionResult = condition();
    var cache = globalThis[CACHE_MAP_KEY];
    if (!cache.has(_hookFn)) {
      cache.set(_hookFn, conditionResult);
    }

    // Extra level of safety for dev environment to notify devs of changed condition
    if (process.env.NODE_ENV !== 'production') {
      if (cache.get(_hookFn) !== conditionResult) {
        throw new Error('Conditional hook called with different condition, this breaks the rules of hooks!');
      }
    }
    if (cache.get(_hookFn)) {
      return newHook.apply(void 0, args);
    } else {
      return oldHook.apply(void 0, args);
    }
  };
  return _hookFn;
}