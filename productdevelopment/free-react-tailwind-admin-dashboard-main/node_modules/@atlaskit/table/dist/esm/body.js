import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
var _excluded = ["idx"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
import React, { Children, useEffect, useMemo } from 'react';
import { useSelection } from './hooks/selection-provider';
import { RowProvider } from './hooks/use-row-id';
import { useTable } from './hooks/use-table';
import { TableBodyProvider } from './hooks/use-table-body';
import { TBody as TBodyPrimitive } from './ui';
/**
 * __Table body__
 */
function TBody(_ref) {
  var rows = _ref.rows,
    children = _ref.children;
  var _useTable = useTable(),
    sortFn = _useTable.sortFn;
  var _useSelection = useSelection(),
    _useSelection2 = _slicedToArray(_useSelection, 2),
    _state = _useSelection2[0],
    _useSelection2$ = _useSelection2[1],
    removeAll = _useSelection2$.removeAll,
    setMax = _useSelection2$.setMax;
  // TODO: this seems like something the user should control or opt into.
  useEffect(function () {
    removeAll === null || removeAll === void 0 || removeAll();
    // eslint-disable-next-line react-hooks/exhaustive-deps -- When the rows change, we [currently] want to call removeAll.
  }, [rows]);
  var childrenCount = Children.count(children);
  var rowsLength = rows === null || rows === void 0 ? void 0 : rows.length;

  // Set data length (via setMax) whenever data changes
  useEffect(function () {
    var numRows = rowsLength !== null && rowsLength !== void 0 ? rowsLength : childrenCount;
    setMax === null || setMax === void 0 || setMax(numRows);
  }, [rowsLength, childrenCount, setMax]);
  var sortedRows = useMemo(function () {
    return rows === null || rows === void 0 ? void 0 : rows.map(function (row, idx) {
      return _objectSpread(_objectSpread({}, row), {}, {
        idx: idx
      });
    }).sort(sortFn);
  }, [rows, sortFn]);
  var renderedChildren = function () {
    if (typeof children === 'function') {
      return sortedRows === null || sortedRows === void 0 ? void 0 : sortedRows.map(function (_ref2) {
        var idx = _ref2.idx,
          row = _objectWithoutProperties(_ref2, _excluded);
        return /*#__PURE__*/React.createElement(RowProvider, {
          key: idx,
          value: idx
        },
        // @ts-expect-error
        children(row));
      });
    }
    var childrenArray = Array.isArray(children) ? children : [children];
    return childrenArray.map(function (row, idx) {
      return /*#__PURE__*/React.createElement(RowProvider, {
        key: idx,
        value: idx
      }, row);
    });
  }();
  return /*#__PURE__*/React.createElement(TableBodyProvider, {
    value: true
  }, /*#__PURE__*/React.createElement(TBodyPrimitive, null, renderedChildren));
}
export default TBody;