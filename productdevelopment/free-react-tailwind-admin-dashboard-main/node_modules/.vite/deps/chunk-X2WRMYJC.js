import {
  _defineProperty,
  _typeof,
  toPropertyKey
} from "./chunk-MU5EOU7I.js";
import {
  require_react
} from "./chunk-2YZST6ER.js";
import {
  __commonJS,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(o);
    }
    module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime4() {
      "use strict";
      module.exports = _regeneratorRuntime4 = function _regeneratorRuntime5() {
        return e;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, {
          value: r2,
          enumerable: true,
          configurable: true,
          writable: true
        }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", {
          value: makeInvokeMethod(t2, r2, c2)
        }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return {
            type: "normal",
            arg: t2.call(e2, r2)
          };
        } catch (t3) {
          return {
            type: "throw",
            arg: t3
          };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof2(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", {
          value: function value(t3, n2) {
            function callInvokeWithMethodAndArg() {
              return new e2(function(e3, r3) {
                invoke(t3, n2, e3, r3);
              });
            }
            return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return {
              value: t,
              done: true
            };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return {
                value: p2.arg,
                done: n2.done
              };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = {
          tryLoc: t2[0]
        };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof2(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return {
          __await: t2
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e2) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
        },
        stop: function stop() {
          this.done = true;
          var t2 = this.tryEntries[0].completion;
          if ("throw" === t2.type) throw t2.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e2) {
          if (this.done) throw e2;
          var r2 = this;
          function handle(n2, o3) {
            return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
          }
          for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
            var i2 = this.tryEntries[o2], a2 = i2.completion;
            if ("root" === i2.tryLoc) return handle("end");
            if (i2.tryLoc <= this.prev) {
              var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
              if (c2 && u2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              } else if (c2) {
                if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              } else {
                if (!u2) throw Error("try statement without catch or finally");
                if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t2, e2) {
          for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
            var o2 = this.tryEntries[r2];
            if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
              var i2 = o2;
              break;
            }
          }
          i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
          var a2 = i2 ? i2.completion : {};
          return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
        },
        complete: function complete(t2, e2) {
          if ("throw" === t2.type) throw t2.arg;
          return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
        },
        finish: function finish(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
          }
        },
        "catch": function _catch(t2) {
          for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
            var r2 = this.tryEntries[e2];
            if (r2.tryLoc === t2) {
              var n2 = r2.completion;
              if ("throw" === n2.type) {
                var o2 = n2.arg;
                resetTryEntry(r2);
              }
              return o2;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e2, r2, n2) {
          return this.delegate = {
            iterator: values(e2),
            resultName: r2,
            nextLoc: n2
          }, "next" === this.method && (this.arg = t), y;
        }
      }, e;
    }
    module.exports = _regeneratorRuntime4, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@statsig/client-core/src/Log.js
var require_Log = __commonJS({
  "node_modules/@statsig/client-core/src/Log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Log = exports.LogLevel = void 0;
    var DEBUG = " DEBUG ";
    var _INFO = "  INFO ";
    var _WARN = "  WARN ";
    var ERROR = " ERROR ";
    function addTag(args) {
      args.unshift("[Statsig]");
      return args;
    }
    exports.LogLevel = {
      None: 0,
      Error: 1,
      Warn: 2,
      Info: 3,
      Debug: 4
    };
    var Log = class _Log {
      static info(...args) {
        if (_Log.level >= exports.LogLevel.Info) {
          console.info(_INFO, ...addTag(args));
        }
      }
      static debug(...args) {
        if (_Log.level >= exports.LogLevel.Debug) {
          console.debug(DEBUG, ...addTag(args));
        }
      }
      static warn(...args) {
        if (_Log.level >= exports.LogLevel.Warn) {
          console.warn(_WARN, ...addTag(args));
        }
      }
      static error(...args) {
        if (_Log.level >= exports.LogLevel.Error) {
          console.error(ERROR, ...addTag(args));
        }
      }
    };
    exports.Log = Log;
    Log.level = exports.LogLevel.Warn;
  }
});

// node_modules/@statsig/client-core/src/$_StatsigGlobal.js
var require_StatsigGlobal = __commonJS({
  "node_modules/@statsig/client-core/src/$_StatsigGlobal.js"(exports) {
    "use strict";
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getInstance = exports._getStatsigGlobalFlag = exports._getStatsigGlobal = void 0;
    var Log_1 = require_Log();
    var _getStatsigGlobal = () => {
      try {
        return typeof __STATSIG__ !== "undefined" ? __STATSIG__ : statsigGlobal;
      } catch (e) {
        return statsigGlobal;
      }
    };
    exports._getStatsigGlobal = _getStatsigGlobal;
    var _getStatsigGlobalFlag = (flag) => {
      return (0, exports._getStatsigGlobal)()[flag];
    };
    exports._getStatsigGlobalFlag = _getStatsigGlobalFlag;
    var _getInstance = (sdkKey) => {
      const gbl = (0, exports._getStatsigGlobal)();
      if (!sdkKey) {
        if (gbl.instances && Object.keys(gbl.instances).length > 1) {
          Log_1.Log.warn("Call made to Statsig global instance without an SDK key but there is more than one client instance. If you are using mulitple clients, please specify the SDK key.");
        }
        return gbl.firstInstance;
      }
      return gbl.instances && gbl.instances[sdkKey];
    };
    exports._getInstance = _getInstance;
    var GLOBAL_KEY = "__STATSIG__";
    var _window = typeof window !== "undefined" ? window : {};
    var _global = typeof global !== "undefined" ? global : {};
    var _globalThis = typeof globalThis !== "undefined" ? globalThis : {};
    var statsigGlobal = (_c = (_b = (_a = _window[GLOBAL_KEY]) !== null && _a !== void 0 ? _a : _global[GLOBAL_KEY]) !== null && _b !== void 0 ? _b : _globalThis[GLOBAL_KEY]) !== null && _c !== void 0 ? _c : {
      instance: exports._getInstance
    };
    _window[GLOBAL_KEY] = statsigGlobal;
    _global[GLOBAL_KEY] = statsigGlobal;
    _globalThis[GLOBAL_KEY] = statsigGlobal;
  }
});

// node_modules/@statsig/client-core/src/Diagnostics.js
var require_Diagnostics = __commonJS({
  "node_modules/@statsig/client-core/src/Diagnostics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Diagnostics = void 0;
    var MARKER_MAP = /* @__PURE__ */ new Map();
    var ACT_START = "start";
    var ACT_END = "end";
    var DIAGNOSTICS_EVENT = "statsig::diagnostics";
    exports.Diagnostics = {
      _getMarkers: (sdkKey) => {
        return MARKER_MAP.get(sdkKey);
      },
      _markInitOverallStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "overall"));
      },
      _markInitOverallEnd: (sdkKey, success, evaluationDetails) => {
        _addMarker(sdkKey, _createMarker({
          success,
          error: success ? void 0 : { name: "InitializeError", message: "Failed to initialize" },
          evaluationDetails
        }, ACT_END, "overall"));
      },
      _markInitNetworkReqStart: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_START, "initialize", "network_request"));
      },
      _markInitNetworkReqEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "network_request"));
      },
      _markInitProcessStart: (sdkKey) => {
        _addMarker(sdkKey, _createMarker({}, ACT_START, "initialize", "process"));
      },
      _markInitProcessEnd: (sdkKey, data) => {
        _addMarker(sdkKey, _createMarker(data, ACT_END, "initialize", "process"));
      },
      _clearMarkers: (sdkKey) => {
        MARKER_MAP.delete(sdkKey);
      },
      _formatError(e) {
        if (!(e && typeof e === "object")) {
          return;
        }
        return {
          code: _safeGetField(e, "code"),
          name: _safeGetField(e, "name"),
          message: _safeGetField(e, "message")
        };
      },
      _getDiagnosticsData(res, attempt, body, e) {
        var _a;
        return {
          success: (res === null || res === void 0 ? void 0 : res.ok) === true,
          statusCode: res === null || res === void 0 ? void 0 : res.status,
          sdkRegion: (_a = res === null || res === void 0 ? void 0 : res.headers) === null || _a === void 0 ? void 0 : _a.get("x-statsig-region"),
          isDelta: body.includes('"is_delta":true') === true ? true : void 0,
          attempt,
          error: exports.Diagnostics._formatError(e)
        };
      },
      _enqueueDiagnosticsEvent(user, logger, sdk, options) {
        const markers = exports.Diagnostics._getMarkers(sdk);
        if (markers == null || markers.length <= 0) {
          return -1;
        }
        const overallInitDuration = markers[markers.length - 1].timestamp - markers[0].timestamp;
        exports.Diagnostics._clearMarkers(sdk);
        const event = _makeDiagnosticsEvent(user, {
          context: "initialize",
          markers: markers.slice(),
          statsigOptions: options
        });
        logger.enqueue(event);
        return overallInitDuration;
      }
    };
    function _createMarker(data, action, key, step) {
      return Object.assign({ key, action, step, timestamp: Date.now() }, data);
    }
    function _makeDiagnosticsEvent(user, data) {
      const latencyEvent = {
        eventName: DIAGNOSTICS_EVENT,
        user,
        value: null,
        metadata: data,
        time: Date.now()
      };
      return latencyEvent;
    }
    function _addMarker(sdkKey, marker) {
      var _a;
      const markers = (_a = MARKER_MAP.get(sdkKey)) !== null && _a !== void 0 ? _a : [];
      markers.push(marker);
      MARKER_MAP.set(sdkKey, markers);
    }
    function _safeGetField(data, field) {
      if (field in data) {
        return data[field];
      }
      return void 0;
    }
  }
});

// node_modules/@statsig/client-core/src/TypingUtils.js
var require_TypingUtils = __commonJS({
  "node_modules/@statsig/client-core/src/TypingUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isTypeMatch = exports._typeOf = void 0;
    function _typeOf(input) {
      return Array.isArray(input) ? "array" : typeof input;
    }
    exports._typeOf = _typeOf;
    function _isTypeMatch(a, b) {
      const typeOf = (x) => Array.isArray(x) ? "array" : x === null ? "null" : typeof x;
      return typeOf(a) === typeOf(b);
    }
    exports._isTypeMatch = _isTypeMatch;
  }
});

// node_modules/@statsig/client-core/src/Hashing.js
var require_Hashing = __commonJS({
  "node_modules/@statsig/client-core/src/Hashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getSortedObject = exports._DJB2Object = exports._DJB2 = void 0;
    var TypingUtils_1 = require_TypingUtils();
    var _DJB22 = (value) => {
      let hash = 0;
      for (let i = 0; i < value.length; i++) {
        const character = value.charCodeAt(i);
        hash = (hash << 5) - hash + character;
        hash = hash & hash;
      }
      return String(hash >>> 0);
    };
    exports._DJB2 = _DJB22;
    var _DJB2Object = (value, maxLevels) => {
      return (0, exports._DJB2)(JSON.stringify((0, exports._getSortedObject)(value, maxLevels)));
    };
    exports._DJB2Object = _DJB2Object;
    var _getSortedObject = (object, maxDepth) => {
      if (object == null) {
        return null;
      }
      const keys = Object.keys(object).sort();
      const sortedObject = {};
      keys.forEach((key) => {
        const value = object[key];
        if (maxDepth === 0 || (0, TypingUtils_1._typeOf)(value) !== "object") {
          sortedObject[key] = value;
          return;
        }
        sortedObject[key] = (0, exports._getSortedObject)(value, maxDepth != null ? maxDepth - 1 : maxDepth);
      });
      return sortedObject;
    };
    exports._getSortedObject = _getSortedObject;
  }
});

// node_modules/@statsig/client-core/src/CacheKey.js
var require_CacheKey = __commonJS({
  "node_modules/@statsig/client-core/src/CacheKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getStorageKey = exports._getUserStorageKey = void 0;
    var Hashing_1 = require_Hashing();
    function _getUserStorageKey(sdkKey, user, customKeyGenerator) {
      var _a;
      if (customKeyGenerator) {
        return customKeyGenerator(sdkKey, user);
      }
      const cids = user && user.customIDs ? user.customIDs : {};
      const parts = [
        `uid:${(_a = user === null || user === void 0 ? void 0 : user.userID) !== null && _a !== void 0 ? _a : ""}`,
        `cids:${Object.keys(cids).sort((leftKey, rightKey) => leftKey.localeCompare(rightKey)).map((key) => `${key}-${cids[key]}`).join(",")}`,
        `k:${sdkKey}`
      ];
      return (0, Hashing_1._DJB2)(parts.join("|"));
    }
    exports._getUserStorageKey = _getUserStorageKey;
    function _getStorageKey2(sdkKey, user, customKeyGenerator) {
      if (user) {
        return _getUserStorageKey(sdkKey, user, customKeyGenerator);
      }
      return (0, Hashing_1._DJB2)(`k:${sdkKey}`);
    }
    exports._getStorageKey = _getStorageKey2;
  }
});

// node_modules/@statsig/client-core/src/NetworkConfig.js
var require_NetworkConfig = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkParam = exports.NetworkDefault = exports.Endpoint = void 0;
    exports.Endpoint = {
      _initialize: "initialize",
      _rgstr: "rgstr",
      _download_config_specs: "download_config_specs"
    };
    exports.NetworkDefault = {
      [exports.Endpoint._rgstr]: "https://prodregistryv2.org/v1",
      [exports.Endpoint._initialize]: "https://featureassets.org/v1",
      [exports.Endpoint._download_config_specs]: "https://api.statsigcdn.com/v1"
    };
    exports.NetworkParam = {
      EventCount: "ec",
      SdkKey: "k",
      SdkType: "st",
      SdkVersion: "sv",
      Time: "t",
      SessionID: "sid",
      StatsigEncoded: "se",
      IsGzipped: "gz"
    };
  }
});

// node_modules/@statsig/client-core/src/SafeJs.js
var require_SafeJs = __commonJS({
  "node_modules/@statsig/client-core/src/SafeJs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getUnloadEvent = exports._getCurrentPageUrlSafe = exports._addDocumentEventListenerSafe = exports._addWindowEventListenerSafe = exports._isServerEnv = exports._getDocumentSafe = exports._getWindowSafe = void 0;
    var _getWindowSafe = () => {
      return typeof window !== "undefined" ? window : null;
    };
    exports._getWindowSafe = _getWindowSafe;
    var _getDocumentSafe = () => {
      var _a;
      const win = (0, exports._getWindowSafe)();
      return (_a = win === null || win === void 0 ? void 0 : win.document) !== null && _a !== void 0 ? _a : null;
    };
    exports._getDocumentSafe = _getDocumentSafe;
    var _isServerEnv = () => {
      if ((0, exports._getDocumentSafe)() !== null) {
        return false;
      }
      const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
      const isVercel = typeof EdgeRuntime === "string";
      return isVercel || isNode;
    };
    exports._isServerEnv = _isServerEnv;
    var _addWindowEventListenerSafe = (key, listener) => {
      const win = (0, exports._getWindowSafe)();
      if (typeof (win === null || win === void 0 ? void 0 : win.addEventListener) === "function") {
        win.addEventListener(key, listener);
      }
    };
    exports._addWindowEventListenerSafe = _addWindowEventListenerSafe;
    var _addDocumentEventListenerSafe = (key, listener) => {
      const doc = (0, exports._getDocumentSafe)();
      if (typeof (doc === null || doc === void 0 ? void 0 : doc.addEventListener) === "function") {
        doc.addEventListener(key, listener);
      }
    };
    exports._addDocumentEventListenerSafe = _addDocumentEventListenerSafe;
    var _getCurrentPageUrlSafe = () => {
      var _a;
      try {
        return (_a = (0, exports._getWindowSafe)()) === null || _a === void 0 ? void 0 : _a.location.href.split(/[?#]/)[0];
      } catch (_b) {
        return;
      }
    };
    exports._getCurrentPageUrlSafe = _getCurrentPageUrlSafe;
    var _getUnloadEvent = () => {
      const win = (0, exports._getWindowSafe)();
      if (!win) {
        return "beforeunload";
      }
      const eventType = "onpagehide" in win ? "pagehide" : "beforeunload";
      return eventType;
    };
    exports._getUnloadEvent = _getUnloadEvent;
  }
});

// node_modules/@statsig/client-core/src/StatsigEvent.js
var require_StatsigEvent = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._createLayerParameterExposure = exports._createConfigExposure = exports._mapExposures = exports._createGateExposure = exports._isExposureEvent = void 0;
    var CONFIG_EXPOSURE_NAME = "statsig::config_exposure";
    var GATE_EXPOSURE_NAME = "statsig::gate_exposure";
    var LAYER_EXPOSURE_NAME = "statsig::layer_exposure";
    var _createExposure = (eventName, user, details, metadata, secondaryExposures) => {
      if (details.bootstrapMetadata) {
        metadata["bootstrapMetadata"] = details.bootstrapMetadata;
      }
      return {
        eventName,
        user,
        value: null,
        metadata: _addEvaluationDetailsToMetadata(details, metadata),
        secondaryExposures,
        time: Date.now()
      };
    };
    var _isExposureEvent = ({ eventName }) => {
      return eventName === GATE_EXPOSURE_NAME || eventName === CONFIG_EXPOSURE_NAME || eventName === LAYER_EXPOSURE_NAME;
    };
    exports._isExposureEvent = _isExposureEvent;
    var _createGateExposure = (user, gate, exposureMapping) => {
      var _a, _b, _c;
      const metadata = {
        gate: gate.name,
        gateValue: String(gate.value),
        ruleID: gate.ruleID
      };
      if (((_a = gate.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = gate.__evaluation.version;
      }
      return _createExposure(GATE_EXPOSURE_NAME, user, gate.details, metadata, _mapExposures((_c = (_b = gate.__evaluation) === null || _b === void 0 ? void 0 : _b.secondary_exposures) !== null && _c !== void 0 ? _c : [], exposureMapping));
    };
    exports._createGateExposure = _createGateExposure;
    function _mapExposures(exposures, exposureMapping) {
      return exposures.map((exposure) => {
        if (typeof exposure === "string") {
          return (exposureMapping !== null && exposureMapping !== void 0 ? exposureMapping : {})[exposure];
        }
        return exposure;
      }).filter((exposure) => exposure != null);
    }
    exports._mapExposures = _mapExposures;
    var _createConfigExposure = (user, config, exposureMapping) => {
      var _a, _b, _c, _d;
      const metadata = {
        config: config.name,
        ruleID: config.ruleID
      };
      if (((_a = config.__evaluation) === null || _a === void 0 ? void 0 : _a.version) != null) {
        metadata["configVersion"] = config.__evaluation.version;
      }
      if (((_b = config.__evaluation) === null || _b === void 0 ? void 0 : _b.passed) != null) {
        metadata["rulePassed"] = String(config.__evaluation.passed);
      }
      return _createExposure(CONFIG_EXPOSURE_NAME, user, config.details, metadata, _mapExposures((_d = (_c = config.__evaluation) === null || _c === void 0 ? void 0 : _c.secondary_exposures) !== null && _d !== void 0 ? _d : [], exposureMapping));
    };
    exports._createConfigExposure = _createConfigExposure;
    var _createLayerParameterExposure = (user, layer, parameterName, exposureMapping) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const evaluation = layer.__evaluation;
      const isExplicit = ((_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.explicit_parameters) === null || _a === void 0 ? void 0 : _a.includes(parameterName)) === true;
      let allocatedExperiment = "";
      let secondaryExposures = (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.undelegated_secondary_exposures) !== null && _b !== void 0 ? _b : [];
      if (isExplicit) {
        allocatedExperiment = (_c = evaluation.allocated_experiment_name) !== null && _c !== void 0 ? _c : "";
        secondaryExposures = (_d = evaluation.secondary_exposures) !== null && _d !== void 0 ? _d : [];
      }
      const parameterRuleIDs = (_e = layer.__evaluation) === null || _e === void 0 ? void 0 : _e.parameter_rule_ids;
      const metadata = {
        config: layer.name,
        parameterName,
        ruleID: (_f = parameterRuleIDs === null || parameterRuleIDs === void 0 ? void 0 : parameterRuleIDs[parameterName]) !== null && _f !== void 0 ? _f : layer.ruleID,
        allocatedExperiment,
        isExplicitParameter: String(isExplicit)
      };
      if (((_g = layer.__evaluation) === null || _g === void 0 ? void 0 : _g.version) != null) {
        metadata["configVersion"] = layer.__evaluation.version;
      }
      return _createExposure(LAYER_EXPOSURE_NAME, user, layer.details, metadata, _mapExposures(secondaryExposures, exposureMapping));
    };
    exports._createLayerParameterExposure = _createLayerParameterExposure;
    var _addEvaluationDetailsToMetadata = (details, metadata) => {
      metadata["reason"] = details.reason;
      if (details.lcut) {
        metadata["lcut"] = String(details.lcut);
      }
      if (details.receivedAt) {
        metadata["receivedAt"] = String(details.receivedAt);
      }
      return metadata;
    };
  }
});

// node_modules/@statsig/client-core/src/StatsigOptionsCommon.js
var require_StatsigOptionsCommon = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigOptionsCommon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoggingEnabledOption = exports.LogEventCompressionMode = void 0;
    exports.LogEventCompressionMode = {
      /** Do not compress request bodies */
      Disabled: "d",
      /** Compress request bodies unless a network proxy is configured */
      Enabled: "e",
      /** Always compress request bodies, even when a proxy is configured */
      Forced: "f"
    };
    exports.LoggingEnabledOption = {
      disabled: "disabled",
      browserOnly: "browser-only",
      always: "always"
    };
  }
});

// node_modules/@statsig/client-core/src/StorageProvider.js
var require_StorageProvider = __commonJS({
  "node_modules/@statsig/client-core/src/StorageProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._setObjectInStorage = exports._getObjectFromStorage = exports.Storage = void 0;
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var inMemoryStore = {};
    var _inMemoryProvider = {
      isReady: () => true,
      isReadyResolver: () => null,
      getProviderName: () => "InMemory",
      getItem: (key) => inMemoryStore[key] ? inMemoryStore[key] : null,
      setItem: (key, value) => {
        inMemoryStore[key] = value;
      },
      removeItem: (key) => {
        delete inMemoryStore[key];
      },
      getAllKeys: () => Object.keys(inMemoryStore)
    };
    var _localStorageProvider = null;
    try {
      const win = (0, SafeJs_1._getWindowSafe)();
      if (win && win.localStorage && typeof win.localStorage.getItem === "function") {
        _localStorageProvider = {
          isReady: () => true,
          isReadyResolver: () => null,
          getProviderName: () => "LocalStorage",
          getItem: (key) => win.localStorage.getItem(key),
          setItem: (key, value) => win.localStorage.setItem(key, value),
          removeItem: (key) => win.localStorage.removeItem(key),
          getAllKeys: () => Object.keys(win.localStorage)
        };
      }
    } catch (error) {
      Log_1.Log.warn("Failed to setup localStorageProvider.");
    }
    var _main = _localStorageProvider !== null && _localStorageProvider !== void 0 ? _localStorageProvider : _inMemoryProvider;
    var _current = _main;
    function _inMemoryBreaker(action) {
      try {
        return action();
      } catch (error) {
        if (error instanceof Error && error.name === "SecurityError") {
          exports.Storage._setProvider(_inMemoryProvider);
          return null;
        }
        throw error;
      }
    }
    exports.Storage = {
      isReady: () => _current.isReady(),
      isReadyResolver: () => _current.isReadyResolver(),
      getProviderName: () => _current.getProviderName(),
      getItem: (key) => _inMemoryBreaker(() => _current.getItem(key)),
      setItem: (key, value) => _inMemoryBreaker(() => _current.setItem(key, value)),
      removeItem: (key) => _current.removeItem(key),
      getAllKeys: () => _current.getAllKeys(),
      // StorageProviderManagment
      _setProvider: (newProvider) => {
        _main = newProvider;
        _current = newProvider;
      },
      _setDisabled: (isDisabled) => {
        if (isDisabled) {
          _current = _inMemoryProvider;
        } else {
          _current = _main;
        }
      }
    };
    function _getObjectFromStorage(key) {
      const value = exports.Storage.getItem(key);
      return JSON.parse(value !== null && value !== void 0 ? value : "null");
    }
    exports._getObjectFromStorage = _getObjectFromStorage;
    function _setObjectInStorage(key, obj) {
      exports.Storage.setItem(key, JSON.stringify(obj));
    }
    exports._setObjectInStorage = _setObjectInStorage;
  }
});

// node_modules/@statsig/client-core/src/UrlConfiguration.js
var require_UrlConfiguration = __commonJS({
  "node_modules/@statsig/client-core/src/UrlConfiguration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlConfiguration = void 0;
    var Hashing_1 = require_Hashing();
    var NetworkConfig_1 = require_NetworkConfig();
    var ENDPOINT_DNS_KEY_MAP = {
      [NetworkConfig_1.Endpoint._initialize]: "i",
      [NetworkConfig_1.Endpoint._rgstr]: "e",
      [NetworkConfig_1.Endpoint._download_config_specs]: "d"
    };
    var UrlConfiguration = class {
      constructor(endpoint, customUrl, customApi, fallbackUrls) {
        this.customUrl = null;
        this.fallbackUrls = null;
        this.endpoint = endpoint;
        this.endpointDnsKey = ENDPOINT_DNS_KEY_MAP[endpoint];
        if (customUrl) {
          this.customUrl = customUrl;
        }
        if (!customUrl && customApi) {
          this.customUrl = customApi.endsWith("/") ? `${customApi}${endpoint}` : `${customApi}/${endpoint}`;
        }
        if (fallbackUrls) {
          this.fallbackUrls = fallbackUrls;
        }
        const defaultApi = NetworkConfig_1.NetworkDefault[endpoint];
        this.defaultUrl = `${defaultApi}/${endpoint}`;
      }
      getUrl() {
        var _a;
        return (_a = this.customUrl) !== null && _a !== void 0 ? _a : this.defaultUrl;
      }
      getChecksum() {
        var _a;
        const fallbacks = ((_a = this.fallbackUrls) !== null && _a !== void 0 ? _a : []).sort().join(",");
        return (0, Hashing_1._DJB2)(this.customUrl + fallbacks);
      }
    };
    exports.UrlConfiguration = UrlConfiguration;
  }
});

// node_modules/@statsig/client-core/src/VisibilityObserving.js
var require_VisibilityObserving = __commonJS({
  "node_modules/@statsig/client-core/src/VisibilityObserving.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._notifyVisibilityChanged = exports._subscribeToVisiblityChanged = exports._isUnloading = exports._isCurrentlyVisible = void 0;
    var SafeJs_1 = require_SafeJs();
    var FOREGROUND = "foreground";
    var BACKGROUND = "background";
    var LISTENERS = [];
    var current = FOREGROUND;
    var isUnloading = false;
    var _isCurrentlyVisible = () => {
      return current === FOREGROUND;
    };
    exports._isCurrentlyVisible = _isCurrentlyVisible;
    var _isUnloading = () => isUnloading;
    exports._isUnloading = _isUnloading;
    var _subscribeToVisiblityChanged = (listener) => {
      LISTENERS.unshift(listener);
    };
    exports._subscribeToVisiblityChanged = _subscribeToVisiblityChanged;
    var _notifyVisibilityChanged = (visibility) => {
      if (visibility === current) {
        return;
      }
      current = visibility;
      LISTENERS.forEach((l) => l(visibility));
    };
    exports._notifyVisibilityChanged = _notifyVisibilityChanged;
    (0, SafeJs_1._addWindowEventListenerSafe)("focus", () => {
      isUnloading = false;
      (0, exports._notifyVisibilityChanged)(FOREGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)("blur", () => (0, exports._notifyVisibilityChanged)(BACKGROUND));
    (0, SafeJs_1._addDocumentEventListenerSafe)("visibilitychange", () => {
      (0, exports._notifyVisibilityChanged)(document.visibilityState === "visible" ? FOREGROUND : BACKGROUND);
    });
    (0, SafeJs_1._addWindowEventListenerSafe)((0, SafeJs_1._getUnloadEvent)(), () => {
      isUnloading = true;
      (0, exports._notifyVisibilityChanged)(BACKGROUND);
    });
  }
});

// node_modules/@statsig/client-core/src/EventLogger.js
var require_EventLogger = __commonJS({
  "node_modules/@statsig/client-core/src/EventLogger.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventLogger = void 0;
    var CacheKey_1 = require_CacheKey();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var SafeJs_1 = require_SafeJs();
    var StatsigEvent_1 = require_StatsigEvent();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var StorageProvider_1 = require_StorageProvider();
    var UrlConfiguration_1 = require_UrlConfiguration();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_QUEUE_SIZE = 100;
    var DEFAULT_FLUSH_INTERVAL_MS = 1e4;
    var MAX_DEDUPER_KEYS = 1e3;
    var DEDUPER_WINDOW_DURATION_MS = 6e5;
    var MAX_FAILED_LOGS = 500;
    var QUICK_FLUSH_WINDOW_MS = 200;
    var EVENT_LOGGER_MAP = {};
    var RetryFailedLogsTrigger = {
      Startup: "startup",
      GainedFocus: "gained_focus"
    };
    var EventLogger = class _EventLogger {
      static _safeFlushAndForget(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a.flush().catch(() => {
        });
      }
      static _safeRetryFailedLogs(sdkKey) {
        var _a;
        (_a = EVENT_LOGGER_MAP[sdkKey]) === null || _a === void 0 ? void 0 : _a._retryFailedLogs(RetryFailedLogsTrigger.GainedFocus);
      }
      constructor(_sdkKey, _emitter, _network, _options) {
        var _a, _b;
        this._sdkKey = _sdkKey;
        this._emitter = _emitter;
        this._network = _network;
        this._options = _options;
        this._queue = [];
        this._lastExposureTimeMap = {};
        this._nonExposedChecks = {};
        this._hasRunQuickFlush = false;
        this._creationTime = Date.now();
        this._loggingEnabled = (_a = _options === null || _options === void 0 ? void 0 : _options.loggingEnabled) !== null && _a !== void 0 ? _a : (_options === null || _options === void 0 ? void 0 : _options.disableLogging) === true ? StatsigOptionsCommon_1.LoggingEnabledOption.disabled : StatsigOptionsCommon_1.LoggingEnabledOption.browserOnly;
        if ((_options === null || _options === void 0 ? void 0 : _options.loggingEnabled) && _options.disableLogging !== void 0) {
          Log_1.Log.warn("Detected both loggingEnabled and disableLogging options. loggingEnabled takes precedence - please remove disableLogging.");
        }
        this._maxQueueSize = (_b = _options === null || _options === void 0 ? void 0 : _options.loggingBufferMaxSize) !== null && _b !== void 0 ? _b : DEFAULT_QUEUE_SIZE;
        const config = _options === null || _options === void 0 ? void 0 : _options.networkConfig;
        this._logEventUrlConfig = new UrlConfiguration_1.UrlConfiguration(NetworkConfig_1.Endpoint._rgstr, config === null || config === void 0 ? void 0 : config.logEventUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.logEventFallbackUrls);
      }
      setLogEventCompressionMode(mode) {
        this._network.setLogEventCompressionMode(mode);
      }
      setLoggingEnabled(loggingEnabled) {
        if (this._loggingEnabled === "disabled" && loggingEnabled !== "disabled") {
          const storageKey = this._getStorageKey();
          const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
          if (events) {
            this._queue.push(...events);
          }
          StorageProvider_1.Storage.removeItem(storageKey);
        }
        this._loggingEnabled = loggingEnabled;
      }
      enqueue(event) {
        if (!this._shouldLogEvent(event)) {
          return;
        }
        this._normalizeAndAppendEvent(event);
        this._quickFlushIfNeeded();
        if (this._queue.length > this._maxQueueSize) {
          _EventLogger._safeFlushAndForget(this._sdkKey);
        }
      }
      incrementNonExposureCount(name) {
        var _a;
        const current = (_a = this._nonExposedChecks[name]) !== null && _a !== void 0 ? _a : 0;
        this._nonExposedChecks[name] = current + 1;
      }
      reset() {
        this.flush().catch(() => {
        });
        this._lastExposureTimeMap = {};
      }
      start() {
        var _a;
        const isServerEnv = (0, SafeJs_1._isServerEnv)();
        if (isServerEnv && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== "always") {
          return;
        }
        EVENT_LOGGER_MAP[this._sdkKey] = this;
        if (!isServerEnv) {
          (0, VisibilityObserving_1._subscribeToVisiblityChanged)((visibility) => {
            if (visibility === "background") {
              _EventLogger._safeFlushAndForget(this._sdkKey);
            } else if (visibility === "foreground") {
              _EventLogger._safeRetryFailedLogs(this._sdkKey);
            }
          });
        }
        this._retryFailedLogs(RetryFailedLogsTrigger.Startup);
        this._startBackgroundFlushInterval();
      }
      stop() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._flushIntervalId) {
            clearInterval(this._flushIntervalId);
            this._flushIntervalId = null;
          }
          delete EVENT_LOGGER_MAP[this._sdkKey];
          yield this.flush();
        });
      }
      flush() {
        return __awaiter(this, void 0, void 0, function* () {
          this._appendAndResetNonExposedChecks();
          if (this._queue.length === 0) {
            return;
          }
          const events = this._queue;
          this._queue = [];
          yield this._sendEvents(events);
        });
      }
      /**
       * We 'Quick Flush' following the very first event enqueued
       * within the quick flush window
       */
      _quickFlushIfNeeded() {
        if (this._hasRunQuickFlush) {
          return;
        }
        this._hasRunQuickFlush = true;
        if (Date.now() - this._creationTime > QUICK_FLUSH_WINDOW_MS) {
          return;
        }
        setTimeout(() => _EventLogger._safeFlushAndForget(this._sdkKey), QUICK_FLUSH_WINDOW_MS);
      }
      _shouldLogEvent(event) {
        var _a;
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingEnabled) !== "always" && (0, SafeJs_1._isServerEnv)()) {
          return false;
        }
        if (!(0, StatsigEvent_1._isExposureEvent)(event)) {
          return true;
        }
        const user = event.user ? event.user : { statsigEnvironment: void 0 };
        const userKey = (0, CacheKey_1._getUserStorageKey)(this._sdkKey, user);
        const metadata = event.metadata ? event.metadata : {};
        const key = [
          event.eventName,
          userKey,
          metadata["gate"],
          metadata["config"],
          metadata["ruleID"],
          metadata["allocatedExperiment"],
          metadata["parameterName"],
          String(metadata["isExplicitParameter"]),
          metadata["reason"]
        ].join("|");
        const previous = this._lastExposureTimeMap[key];
        const now = Date.now();
        if (previous && now - previous < DEDUPER_WINDOW_DURATION_MS) {
          return false;
        }
        if (Object.keys(this._lastExposureTimeMap).length > MAX_DEDUPER_KEYS) {
          this._lastExposureTimeMap = {};
        }
        this._lastExposureTimeMap[key] = now;
        return true;
      }
      _sendEvents(events) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          if (this._loggingEnabled === "disabled") {
            this._saveFailedLogsToStorage(events);
            return false;
          }
          try {
            const isClosing = (0, VisibilityObserving_1._isUnloading)();
            const shouldUseBeacon = isClosing && this._network.isBeaconSupported() && ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.networkOverrideFunc) == null;
            this._emitter({
              name: "pre_logs_flushed",
              events
            });
            const response = shouldUseBeacon ? this._sendEventsViaBeacon(events) : yield this._sendEventsViaPost(events);
            if (response.success) {
              this._emitter({
                name: "logs_flushed",
                events
              });
              return true;
            } else {
              Log_1.Log.warn("Failed to flush events.");
              this._saveFailedLogsToStorage(events);
              return false;
            }
          } catch (_c) {
            Log_1.Log.warn("Failed to flush events.");
            return false;
          }
        });
      }
      _sendEventsViaPost(events) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const result = yield this._network.post(this._getRequestData(events));
          const code = (_a = result === null || result === void 0 ? void 0 : result.code) !== null && _a !== void 0 ? _a : -1;
          return { success: code >= 200 && code < 300 };
        });
      }
      _sendEventsViaBeacon(events) {
        return {
          success: this._network.beacon(this._getRequestData(events))
        };
      }
      _getRequestData(events) {
        return {
          sdkKey: this._sdkKey,
          data: {
            events
          },
          urlConfig: this._logEventUrlConfig,
          retries: 3,
          isCompressable: true,
          params: {
            [NetworkConfig_1.NetworkParam.EventCount]: String(events.length)
          },
          credentials: "same-origin"
        };
      }
      _saveFailedLogsToStorage(events) {
        while (events.length > MAX_FAILED_LOGS) {
          events.shift();
        }
        const storageKey = this._getStorageKey();
        try {
          const savedEvents = this._getFailedLogsFromStorage(storageKey);
          (0, StorageProvider_1._setObjectInStorage)(storageKey, [...savedEvents, ...events]);
        } catch (_a) {
          Log_1.Log.warn("Unable to save failed logs to storage");
        }
      }
      _getFailedLogsFromStorage(storageKey) {
        let savedEvents = [];
        try {
          const retrieved = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
          if (Array.isArray(retrieved)) {
            savedEvents = retrieved;
          }
          return savedEvents;
        } catch (_a) {
          return [];
        }
      }
      _retryFailedLogs(trigger) {
        const storageKey = this._getStorageKey();
        (() => __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const events = (0, StorageProvider_1._getObjectFromStorage)(storageKey);
          if (!events) {
            return;
          }
          if (trigger === RetryFailedLogsTrigger.Startup) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
          const isSuccess = yield this._sendEvents(events);
          if (isSuccess && trigger === RetryFailedLogsTrigger.GainedFocus) {
            StorageProvider_1.Storage.removeItem(storageKey);
          }
        }))().catch(() => {
          Log_1.Log.warn("Failed to flush stored logs");
        });
      }
      _getStorageKey() {
        return `statsig.failed_logs.${(0, Hashing_1._DJB2)(this._sdkKey)}`;
      }
      _normalizeAndAppendEvent(event) {
        if (event.user) {
          event.user = Object.assign({}, event.user);
          delete event.user.privateAttributes;
        }
        const extras = {};
        const currentPage = this._getCurrentPageUrl();
        if (currentPage) {
          extras.statsigMetadata = { currentPage };
        }
        const final = Object.assign(Object.assign({}, event), extras);
        Log_1.Log.debug("Enqueued Event:", final);
        this._queue.push(final);
      }
      _appendAndResetNonExposedChecks() {
        if (Object.keys(this._nonExposedChecks).length === 0) {
          return;
        }
        this._normalizeAndAppendEvent({
          eventName: "statsig::non_exposed_checks",
          user: null,
          time: Date.now(),
          metadata: {
            checks: Object.assign({}, this._nonExposedChecks)
          }
        });
        this._nonExposedChecks = {};
      }
      _getCurrentPageUrl() {
        var _a;
        if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.includeCurrentPageUrlWithEvents) === false) {
          return;
        }
        return (0, SafeJs_1._getCurrentPageUrlSafe)();
      }
      _startBackgroundFlushInterval() {
        var _a, _b;
        const flushInterval = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.loggingIntervalMs) !== null && _b !== void 0 ? _b : DEFAULT_FLUSH_INTERVAL_MS;
        const intervalId = setInterval(() => {
          const logger = EVENT_LOGGER_MAP[this._sdkKey];
          if (!logger || logger._flushIntervalId !== intervalId) {
            clearInterval(intervalId);
          } else {
            _EventLogger._safeFlushAndForget(this._sdkKey);
          }
        }, flushInterval);
        this._flushIntervalId = intervalId;
      }
    };
    exports.EventLogger = EventLogger;
  }
});

// node_modules/@statsig/client-core/src/StatsigMetadata.js
var require_StatsigMetadata = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigMetadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigMetadataProvider = exports.SDK_VERSION = void 0;
    exports.SDK_VERSION = "3.29.1";
    var metadata = {
      sdkVersion: exports.SDK_VERSION,
      sdkType: "js-mono"
      // js-mono is overwritten by Precomp and OnDevice clients
    };
    exports.StatsigMetadataProvider = {
      get: () => metadata,
      add: (additions) => {
        metadata = Object.assign(Object.assign({}, metadata), additions);
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ClientInterfaces.js
var require_ClientInterfaces = __commonJS({
  "node_modules/@statsig/client-core/src/ClientInterfaces.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/UUID.js
var require_UUID = __commonJS({
  "node_modules/@statsig/client-core/src/UUID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUUID = void 0;
    function getUUID() {
      if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
        return crypto.randomUUID();
      }
      let d = (/* @__PURE__ */ new Date()).getTime();
      let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
      const y = "89ab"[Math.floor(Math.random() * 4)];
      return `xxxxxxxx-xxxx-4xxx-${y}xxx-xxxxxxxxxxxx`.replace(/[xy]/g, (c) => {
        let r = Math.random() * 16;
        if (d > 0) {
          r = (d + r) % 16 | 0;
          d = Math.floor(d / 16);
        } else {
          r = (d2 + r) % 16 | 0;
          d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : r & 7 | 8).toString(16);
      });
    }
    exports.getUUID = getUUID;
  }
});

// node_modules/@statsig/client-core/src/StableID.js
var require_StableID = __commonJS({
  "node_modules/@statsig/client-core/src/StableID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCookieName = exports.StableID = void 0;
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var SafeJs_1 = require_SafeJs();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var PROMISE_MAP = {};
    var COOKIE_ENABLED_MAP = {};
    var DISABLED_MAP = {};
    exports.StableID = {
      cookiesEnabled: false,
      randomID: Math.random().toString(36),
      get: (sdkKey) => {
        if (DISABLED_MAP[sdkKey]) {
          return null;
        }
        if (PROMISE_MAP[sdkKey] != null) {
          return PROMISE_MAP[sdkKey];
        }
        let stableID = null;
        stableID = _loadFromCookie(sdkKey);
        if (stableID != null) {
          PROMISE_MAP[sdkKey] = stableID;
          _persistToStorage(stableID, sdkKey);
          return stableID;
        }
        stableID = _loadFromStorage(sdkKey);
        if (stableID == null) {
          stableID = (0, UUID_1.getUUID)();
        }
        _persistToStorage(stableID, sdkKey);
        _persistToCookie(stableID, sdkKey);
        PROMISE_MAP[sdkKey] = stableID;
        return stableID;
      },
      setOverride: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = override;
        _persistToStorage(override, sdkKey);
        _persistToCookie(override, sdkKey);
      },
      _setCookiesEnabled: (sdkKey, cookiesEnabled) => {
        COOKIE_ENABLED_MAP[sdkKey] = cookiesEnabled;
      },
      _setDisabled: (sdkKey, disabled) => {
        DISABLED_MAP[sdkKey] = disabled;
      }
    };
    function _getStableIDStorageKey(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(stableID, sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, stableID);
      } catch (e) {
        Log_1.Log.warn("Failed to save StableID to storage");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getStableIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
    function _loadFromCookie(sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || (0, SafeJs_1._getDocumentSafe)() == null) {
        return null;
      }
      const cookies = document.cookie.split(";");
      for (const cookie of cookies) {
        const [key, value] = cookie.trim().split("=");
        if (key === getCookieName(sdkKey)) {
          return decodeURIComponent(value);
        }
      }
      return null;
    }
    function _persistToCookie(stableID, sdkKey) {
      if (!COOKIE_ENABLED_MAP[sdkKey] || (0, SafeJs_1._getDocumentSafe)() == null) {
        return;
      }
      const expiryDate = /* @__PURE__ */ new Date();
      expiryDate.setFullYear(expiryDate.getFullYear() + 1);
      document.cookie = `${getCookieName(sdkKey)}=${encodeURIComponent(stableID)}; expires=${expiryDate.toUTCString()}; path=/`;
    }
    function getCookieName(sdkKey) {
      return `statsig.stable_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    exports.getCookieName = getCookieName;
  }
});

// node_modules/@statsig/client-core/src/StatsigUser.js
var require_StatsigUser = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._getFullUserHash = exports._normalizeUser = void 0;
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    function _normalizeUser(original, options, fallbackEnvironment) {
      try {
        const copy = JSON.parse(JSON.stringify(original));
        if (options != null && options.environment != null) {
          copy.statsigEnvironment = options.environment;
        } else if (fallbackEnvironment != null) {
          copy.statsigEnvironment = { tier: fallbackEnvironment };
        }
        return copy;
      } catch (error) {
        Log_1.Log.error("Failed to JSON.stringify user");
        return { statsigEnvironment: void 0 };
      }
    }
    exports._normalizeUser = _normalizeUser;
    function _getFullUserHash2(user) {
      return user ? (0, Hashing_1._DJB2Object)(user) : null;
    }
    exports._getFullUserHash = _getFullUserHash2;
  }
});

// node_modules/@statsig/client-core/src/TypedJsonParse.js
var require_TypedJsonParse = __commonJS({
  "node_modules/@statsig/client-core/src/TypedJsonParse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._typedJsonParse = void 0;
    var Log_1 = require_Log();
    function _typedJsonParse(data, guard, typeName) {
      try {
        const result = JSON.parse(data);
        if (result && typeof result === "object" && guard in result) {
          return result;
        }
      } catch (_a) {
      }
      Log_1.Log.error(`Failed to parse ${typeName}`);
      return null;
    }
    exports._typedJsonParse = _typedJsonParse;
  }
});

// node_modules/@statsig/client-core/src/DataAdapterCore.js
var require_DataAdapterCore = __commonJS({
  "node_modules/@statsig/client-core/src/DataAdapterCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeDataAdapterResult = exports.DataAdapterCore = void 0;
    var Log_1 = require_Log();
    var StableID_1 = require_StableID();
    var StatsigUser_1 = require_StatsigUser();
    var StorageProvider_1 = require_StorageProvider();
    var TypedJsonParse_1 = require_TypedJsonParse();
    var CACHE_LIMIT = 10;
    var MAX_CACHE_WRITE_ATTEMPTS = 8;
    var DataAdapterCore2 = class {
      constructor(_adapterName, _cacheSuffix) {
        this._adapterName = _adapterName;
        this._cacheSuffix = _cacheSuffix;
        this._options = null;
        this._sdkKey = null;
        this._cacheLimit = CACHE_LIMIT;
        this._lastModifiedStoreKey = `statsig.last_modified_time.${_cacheSuffix}`;
        this._inMemoryCache = new InMemoryCache();
      }
      attach(sdkKey, options, _network) {
        this._sdkKey = sdkKey;
        this._options = options;
      }
      getDataSync(user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        const inMem = this._inMemoryCache.get(cacheKey, normalized);
        if (inMem && this._getIsCacheValueValid(inMem)) {
          return inMem;
        }
        const cache2 = this._loadFromCache(cacheKey);
        if (cache2 && this._getIsCacheValueValid(cache2)) {
          this._inMemoryCache.add(cacheKey, cache2, this._cacheLimit);
          return this._inMemoryCache.get(cacheKey, normalized);
        }
        return null;
      }
      setData(data, user) {
        const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
        const cacheKey = this._getCacheKey(normalized);
        this._inMemoryCache.add(cacheKey, _makeDataAdapterResult("Bootstrap", data, null, normalized), this._cacheLimit);
      }
      _getIsCacheValueValid(current) {
        return current.stableID == null || current.stableID === StableID_1.StableID.get(this._getSdkKey());
      }
      _getDataAsyncImpl(current, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!StorageProvider_1.Storage.isReady()) {
            yield StorageProvider_1.Storage.isReadyResolver();
          }
          const cache2 = current !== null && current !== void 0 ? current : this.getDataSync(user);
          const ops = [this._fetchAndPrepFromNetwork(cache2, user, options)];
          if (options === null || options === void 0 ? void 0 : options.timeoutMs) {
            ops.push(new Promise((r) => setTimeout(r, options.timeoutMs)).then(() => {
              Log_1.Log.debug("Fetching latest value timed out");
              return null;
            }));
          }
          return yield Promise.race(ops);
        });
      }
      _prefetchDataImpl(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const normalized = user && (0, StatsigUser_1._normalizeUser)(user, this._options);
          const cacheKey = this._getCacheKey(normalized);
          const result = yield this._getDataAsyncImpl(null, normalized, options);
          if (result) {
            this._inMemoryCache.add(cacheKey, Object.assign(Object.assign({}, result), { source: "Prefetch" }), this._cacheLimit);
          }
        });
      }
      _fetchAndPrepFromNetwork(cachedResult, user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const cachedData = (_a = cachedResult === null || cachedResult === void 0 ? void 0 : cachedResult.data) !== null && _a !== void 0 ? _a : null;
          const isCacheValidFor204 = cachedResult != null && this._isCachedResultValidFor204(cachedResult, user);
          const latest = yield this._fetchFromNetwork(cachedData, user, options, isCacheValidFor204);
          if (!latest) {
            Log_1.Log.debug("No response returned for latest value");
            return null;
          }
          const response = (0, TypedJsonParse_1._typedJsonParse)(latest, "has_updates", "Response");
          const sdkKey = this._getSdkKey();
          const stableID = StableID_1.StableID.get(sdkKey);
          let result = null;
          if ((response === null || response === void 0 ? void 0 : response.has_updates) === true) {
            result = _makeDataAdapterResult("Network", latest, stableID, user);
          } else if (cachedData && (response === null || response === void 0 ? void 0 : response.has_updates) === false) {
            result = _makeDataAdapterResult("NetworkNotModified", cachedData, stableID, user);
          } else {
            return null;
          }
          const cacheKey = this._getCacheKey(user);
          this._inMemoryCache.add(cacheKey, result, this._cacheLimit);
          this._writeToCache(cacheKey, result);
          return result;
        });
      }
      _getSdkKey() {
        if (this._sdkKey != null) {
          return this._sdkKey;
        }
        Log_1.Log.error(`${this._adapterName} is not attached to a Client`);
        return "";
      }
      _loadFromCache(cacheKey) {
        var _a;
        const cache2 = (_a = StorageProvider_1.Storage.getItem) === null || _a === void 0 ? void 0 : _a.call(StorageProvider_1.Storage, cacheKey);
        if (cache2 == null) {
          return null;
        }
        const result = (0, TypedJsonParse_1._typedJsonParse)(cache2, "source", "Cached Result");
        return result ? Object.assign(Object.assign({}, result), { source: "Cache" }) : null;
      }
      _writeToCache(cacheKey, result) {
        const resultString = JSON.stringify(result);
        for (let i = 0; i < MAX_CACHE_WRITE_ATTEMPTS; i++) {
          try {
            StorageProvider_1.Storage.setItem(cacheKey, resultString);
            break;
          } catch (error) {
            if (!(error instanceof Error) || !(error.toString().includes("QuotaExceededError") || error.toString().includes("QUOTA_EXCEEDED_ERR")) || this._cacheLimit <= 1) {
              throw error;
            }
            this._cacheLimit = Math.ceil(this._cacheLimit / 2);
            this._runLocalStorageCacheEviction(cacheKey, this._cacheLimit - 1);
          }
        }
        this._runLocalStorageCacheEviction(cacheKey);
      }
      _runLocalStorageCacheEviction(cacheKey, cacheLimit = this._cacheLimit) {
        var _a;
        const lastModifiedTimeMap = (_a = (0, StorageProvider_1._getObjectFromStorage)(this._lastModifiedStoreKey)) !== null && _a !== void 0 ? _a : {};
        lastModifiedTimeMap[cacheKey] = Date.now();
        const evictableKeys = _getEvictableKeys(lastModifiedTimeMap, cacheLimit);
        for (const evictable of evictableKeys) {
          delete lastModifiedTimeMap[evictable];
          StorageProvider_1.Storage.removeItem(evictable);
        }
        (0, StorageProvider_1._setObjectInStorage)(this._lastModifiedStoreKey, lastModifiedTimeMap);
      }
    };
    exports.DataAdapterCore = DataAdapterCore2;
    function _makeDataAdapterResult(source, data, stableID, user) {
      return {
        source,
        data,
        receivedAt: Date.now(),
        stableID,
        fullUserHash: (0, StatsigUser_1._getFullUserHash)(user)
      };
    }
    exports._makeDataAdapterResult = _makeDataAdapterResult;
    var InMemoryCache = class {
      constructor() {
        this._data = {};
      }
      get(cacheKey, user) {
        var _a;
        const result = this._data[cacheKey];
        const cached = result === null || result === void 0 ? void 0 : result.stableID;
        const provided = (_a = user === null || user === void 0 ? void 0 : user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (provided && cached && provided !== cached) {
          Log_1.Log.warn("'StatsigUser.customIDs.stableID' mismatch");
          return null;
        }
        return result;
      }
      add(cacheKey, value, cacheLimit) {
        const evictableKeys = _getEvictableKeys(this._data, cacheLimit - 1);
        for (const evictable of evictableKeys) {
          delete this._data[evictable];
        }
        this._data[cacheKey] = value;
      }
      merge(values) {
        this._data = Object.assign(Object.assign({}, this._data), values);
      }
    };
    function _getEvictableKeys(data, limit) {
      const keys = Object.keys(data);
      if (keys.length <= limit) {
        return [];
      }
      if (limit === 0) {
        return keys;
      }
      return keys.sort((keyA, keyB) => {
        const valueA = data[keyA];
        const valueB = data[keyB];
        if (typeof valueA === "object" && typeof valueB === "object") {
          return valueA.receivedAt - valueB.receivedAt;
        }
        return valueA - valueB;
      }).slice(0, keys.length - limit);
    }
  }
});

// node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js
var require_DownloadConfigSpecsResponse = __commonJS({
  "node_modules/@statsig/client-core/src/DownloadConfigSpecsResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/SDKType.js
var require_SDKType = __commonJS({
  "node_modules/@statsig/client-core/src/SDKType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKType = void 0;
    var SDK_CLIENT = {};
    var suffix;
    exports.SDKType = {
      _get: (sdkKey) => {
        var _a;
        return ((_a = SDK_CLIENT[sdkKey]) !== null && _a !== void 0 ? _a : "js-mono") + (suffix !== null && suffix !== void 0 ? suffix : "");
      },
      _setClientType(sdkKey, client) {
        SDK_CLIENT[sdkKey] = client;
      },
      _setBindingType(binding) {
        if (!suffix || suffix === "-react") {
          suffix = "-" + binding;
        }
      }
    };
  }
});

// node_modules/@statsig/client-core/src/ErrorBoundary.js
var require_ErrorBoundary = __commonJS({
  "node_modules/@statsig/client-core/src/ErrorBoundary.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorBoundary = exports.EXCEPTION_ENDPOINT = void 0;
    var Log_1 = require_Log();
    var SDKType_1 = require_SDKType();
    var StatsigMetadata_1 = require_StatsigMetadata();
    exports.EXCEPTION_ENDPOINT = "https://statsigapi.net/v1/sdk_exception";
    var UNKNOWN_ERROR = "[Statsig] UnknownError";
    var ErrorBoundary = class {
      constructor(_sdkKey, _options, _emitter, _lastSeenError) {
        this._sdkKey = _sdkKey;
        this._options = _options;
        this._emitter = _emitter;
        this._lastSeenError = _lastSeenError;
        this._seen = /* @__PURE__ */ new Set();
      }
      wrap(instance, namePrefix) {
        try {
          const obj = instance;
          _getAllInstanceMethodNames(obj).forEach((name) => {
            const original = obj[name];
            if ("$EB" in original) {
              return;
            }
            obj[name] = (...args) => {
              return this._capture(namePrefix ? `${namePrefix}:${name}` : name, () => original.apply(instance, args));
            };
            obj[name].$EB = true;
          });
        } catch (err) {
          this._onError("eb:wrap", err);
        }
      }
      logError(tag, error) {
        this._onError(tag, error);
      }
      getLastSeenErrorAndReset() {
        const tempError = this._lastSeenError;
        this._lastSeenError = void 0;
        return tempError !== null && tempError !== void 0 ? tempError : null;
      }
      attachErrorIfNoneExists(error) {
        if (this._lastSeenError) {
          return;
        }
        this._lastSeenError = _resolveError(error);
      }
      _capture(tag, task) {
        try {
          const res = task();
          if (res && res instanceof Promise) {
            return res.catch((err) => this._onError(tag, err));
          }
          return res;
        } catch (error) {
          this._onError(tag, error);
          return null;
        }
      }
      _onError(tag, error) {
        try {
          Log_1.Log.warn(`Caught error in ${tag}`, { error });
          const impl = () => __awaiter(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g;
            const unwrapped = error ? error : Error(UNKNOWN_ERROR);
            const isError = unwrapped instanceof Error;
            const name = isError ? unwrapped.name : "No Name";
            const resolvedError = _resolveError(unwrapped);
            this._lastSeenError = resolvedError;
            if (this._seen.has(name)) {
              return;
            }
            this._seen.add(name);
            if ((_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.preventAllNetworkTraffic) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag
              });
              return;
            }
            const sdkType = SDKType_1.SDKType._get(this._sdkKey);
            const statsigMetadata = StatsigMetadata_1.StatsigMetadataProvider.get();
            const info = isError ? unwrapped.stack : _getDescription(unwrapped);
            const body = Object.assign({ tag, exception: name, info, statsigOptions: _getStatsigOptionLoggingCopy(this._options) }, Object.assign(Object.assign({}, statsigMetadata), { sdkType }));
            const func = (_f = (_e = (_d = this._options) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.networkOverrideFunc) !== null && _f !== void 0 ? _f : fetch;
            yield func(exports.EXCEPTION_ENDPOINT, {
              method: "POST",
              headers: {
                "STATSIG-API-KEY": this._sdkKey,
                "STATSIG-SDK-TYPE": String(sdkType),
                "STATSIG-SDK-VERSION": String(statsigMetadata.sdkVersion),
                "Content-Type": "application/json"
              },
              body: JSON.stringify(body)
            });
            (_g = this._emitter) === null || _g === void 0 ? void 0 : _g.call(this, {
              name: "error",
              error,
              tag
            });
          });
          impl().then(() => {
          }).catch(() => {
          });
        } catch (_error) {
        }
      }
    };
    exports.ErrorBoundary = ErrorBoundary;
    function _resolveError(error) {
      if (error instanceof Error) {
        return error;
      } else if (typeof error === "string") {
        return new Error(error);
      } else {
        return new Error("An unknown error occurred.");
      }
    }
    function _getDescription(obj) {
      try {
        return JSON.stringify(obj);
      } catch (_a) {
        return UNKNOWN_ERROR;
      }
    }
    function _getAllInstanceMethodNames(instance) {
      const names = /* @__PURE__ */ new Set();
      let proto = Object.getPrototypeOf(instance);
      while (proto && proto !== Object.prototype) {
        Object.getOwnPropertyNames(proto).filter((prop) => typeof (proto === null || proto === void 0 ? void 0 : proto[prop]) === "function").forEach((name) => names.add(name));
        proto = Object.getPrototypeOf(proto);
      }
      return Array.from(names);
    }
    function _getStatsigOptionLoggingCopy(options) {
      if (!options) {
        return {};
      }
      const loggingCopy = {};
      Object.keys(options).forEach((key) => {
        const option = key;
        const value = options[option];
        const valueType = typeof value;
        switch (valueType) {
          case "number":
          case "bigint":
          case "boolean":
            loggingCopy[String(option)] = value;
            break;
          case "string":
            if (value.length < 50) {
              loggingCopy[String(option)] = value;
            } else {
              loggingCopy[String(option)] = "set";
            }
            break;
          case "object":
            if (option === "environment") {
              loggingCopy["environment"] = value;
            } else if (option === "networkConfig") {
              loggingCopy["networkConfig"] = value;
            } else {
              loggingCopy[String(option)] = value != null ? "set" : "unset";
            }
            break;
          default:
        }
      });
      return loggingCopy;
    }
  }
});

// node_modules/@statsig/client-core/src/EvaluationOptions.js
var require_EvaluationOptions = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationOptions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/EvaluationTypes.js
var require_EvaluationTypes = __commonJS({
  "node_modules/@statsig/client-core/src/EvaluationTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/InitializeResponse.js
var require_InitializeResponse = __commonJS({
  "node_modules/@statsig/client-core/src/InitializeResponse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/MemoKey.js
var require_MemoKey = __commonJS({
  "node_modules/@statsig/client-core/src/MemoKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMemoKey = exports.MemoPrefix = void 0;
    exports.MemoPrefix = {
      _gate: "g",
      _dynamicConfig: "c",
      _experiment: "e",
      _configList: "cl",
      _layer: "l",
      _paramStore: "p"
    };
    var EXIST_KEYS = /* @__PURE__ */ new Set([
      // Add keys that should be memoized based only on their existence, not their value
    ]);
    var DO_NOT_MEMO_KEYS = /* @__PURE__ */ new Set([
      // Add keys that if exist, should not be memoized
      "userPersistedValues"
    ]);
    function createMemoKey(prefix, name, options) {
      let cacheKey = `${prefix}|${name}`;
      if (!options) {
        return cacheKey;
      }
      for (const key of Object.keys(options)) {
        if (DO_NOT_MEMO_KEYS.has(key)) {
          return void 0;
        }
        if (EXIST_KEYS.has(key)) {
          cacheKey += `|${key}=true`;
        } else {
          cacheKey += `|${key}=${options[key]}`;
        }
      }
      return cacheKey;
    }
    exports.createMemoKey = createMemoKey;
  }
});

// node_modules/@statsig/client-core/src/DnsTxtQuery.js
var require_DnsTxtQuery = __commonJS({
  "node_modules/@statsig/client-core/src/DnsTxtQuery.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._fetchTxtRecords = void 0;
    var FEATURE_ASSETS_DNS_QUERY = new Uint8Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      13,
      102,
      101,
      97,
      116,
      117,
      114,
      101,
      97,
      115,
      115,
      101,
      116,
      115,
      3,
      111,
      114,
      103,
      0,
      0,
      16,
      0,
      1
    ]);
    var DNS_QUERY_ENDPOINT = "https://cloudflare-dns.com/dns-query";
    var DOMAIN_CHARS = [
      "i",
      // initialize
      "e",
      // events
      "d"
      // dcs
    ];
    var MAX_START_LOOKUP = 200;
    function _fetchTxtRecords(networkFunc) {
      return __awaiter(this, void 0, void 0, function* () {
        const response = yield networkFunc(DNS_QUERY_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/dns-message",
            Accept: "application/dns-message"
          },
          body: FEATURE_ASSETS_DNS_QUERY
        });
        if (!response.ok) {
          const err = new Error("Failed to fetch TXT records from DNS");
          err.name = "DnsTxtFetchError";
          throw err;
        }
        const data = yield response.arrayBuffer();
        const bytes = new Uint8Array(data);
        return _parseDnsResponse(bytes);
      });
    }
    exports._fetchTxtRecords = _fetchTxtRecords;
    function _parseDnsResponse(input) {
      const start = input.findIndex((byte, index) => index < MAX_START_LOOKUP && String.fromCharCode(byte) === "=" && DOMAIN_CHARS.includes(String.fromCharCode(input[index - 1])));
      if (start === -1) {
        const err = new Error("Failed to parse TXT records from DNS");
        err.name = "DnsTxtParseError";
        throw err;
      }
      let result = "";
      for (let i = start - 1; i < input.length; i++) {
        result += String.fromCharCode(input[i]);
      }
      return result.split(",");
    }
  }
});

// node_modules/@statsig/client-core/src/NetworkFallbackResolver.js
var require_NetworkFallbackResolver = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkFallbackResolver.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._isDomainFailure = exports.NetworkFallbackResolver = void 0;
    var DnsTxtQuery_1 = require_DnsTxtQuery();
    var Hashing_1 = require_Hashing();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var DEFAULT_TTL_MS = 7 * 24 * 60 * 60 * 1e3;
    var COOLDOWN_TIME_MS = 4 * 60 * 60 * 1e3;
    var NetworkFallbackResolver = class {
      constructor(options) {
        var _a;
        this._fallbackInfo = null;
        this._errorBoundary = null;
        this._dnsQueryCooldowns = {};
        this._networkOverrideFunc = (_a = options.networkConfig) === null || _a === void 0 ? void 0 : _a.networkOverrideFunc;
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
      }
      tryBumpExpiryTime(sdkKey, urlConfig) {
        var _a;
        const info = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint];
        if (!info) {
          return;
        }
        info.expiryTime = Date.now() + DEFAULT_TTL_MS;
        _tryWriteFallbackInfoToCache(sdkKey, Object.assign(Object.assign({}, this._fallbackInfo), { [urlConfig.endpoint]: info }));
      }
      getActiveFallbackUrl(sdkKey, urlConfig) {
        var _a, _b;
        if (urlConfig.customUrl != null && urlConfig.fallbackUrls != null) {
          return null;
        }
        let info = this._fallbackInfo;
        if (info == null) {
          info = (_a = _readFallbackInfoFromCache(sdkKey)) !== null && _a !== void 0 ? _a : {};
          this._fallbackInfo = info;
        }
        const entry = info[urlConfig.endpoint];
        if (!entry || Date.now() > ((_b = entry.expiryTime) !== null && _b !== void 0 ? _b : 0) || urlConfig.getChecksum() !== entry.urlConfigChecksum) {
          delete info[urlConfig.endpoint];
          this._fallbackInfo = info;
          _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
          return null;
        }
        if (entry.url) {
          return entry.url;
        }
        return null;
      }
      tryFetchUpdatedFallbackInfo(sdkKey, urlConfig, errorMessage, timedOut) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          try {
            if (!_isDomainFailure(errorMessage, timedOut)) {
              return false;
            }
            const canUseNetworkFallbacks = urlConfig.customUrl == null && urlConfig.fallbackUrls == null;
            const urls = canUseNetworkFallbacks ? yield this._tryFetchFallbackUrlsFromNetwork(urlConfig) : urlConfig.fallbackUrls;
            const newUrl = this._pickNewFallbackUrl((_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[urlConfig.endpoint], urls);
            if (!newUrl) {
              return false;
            }
            this._updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl);
            return true;
          } catch (error) {
            (_b = this._errorBoundary) === null || _b === void 0 ? void 0 : _b.logError("tryFetchUpdatedFallbackInfo", error);
            return false;
          }
        });
      }
      _updateFallbackInfoWithNewUrl(sdkKey, urlConfig, newUrl) {
        var _a, _b, _c;
        const newFallbackInfo = {
          urlConfigChecksum: urlConfig.getChecksum(),
          url: newUrl,
          expiryTime: Date.now() + DEFAULT_TTL_MS,
          previous: []
        };
        const endpoint = urlConfig.endpoint;
        const previousInfo = (_a = this._fallbackInfo) === null || _a === void 0 ? void 0 : _a[endpoint];
        if (previousInfo) {
          newFallbackInfo.previous.push(...previousInfo.previous);
        }
        if (newFallbackInfo.previous.length > 10) {
          newFallbackInfo.previous = [];
        }
        const previousUrl = (_c = (_b = this._fallbackInfo) === null || _b === void 0 ? void 0 : _b[endpoint]) === null || _c === void 0 ? void 0 : _c.url;
        if (previousUrl != null) {
          newFallbackInfo.previous.push(previousUrl);
        }
        this._fallbackInfo = Object.assign(Object.assign({}, this._fallbackInfo), { [endpoint]: newFallbackInfo });
        _tryWriteFallbackInfoToCache(sdkKey, this._fallbackInfo);
      }
      _tryFetchFallbackUrlsFromNetwork(urlConfig) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const cooldown = this._dnsQueryCooldowns[urlConfig.endpoint];
          if (cooldown && Date.now() < cooldown) {
            return null;
          }
          this._dnsQueryCooldowns[urlConfig.endpoint] = Date.now() + COOLDOWN_TIME_MS;
          const result = [];
          const records = yield (0, DnsTxtQuery_1._fetchTxtRecords)((_a = this._networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch);
          const path = _extractPathFromUrl(urlConfig.defaultUrl);
          for (const record of records) {
            if (!record.startsWith(urlConfig.endpointDnsKey + "=")) {
              continue;
            }
            const parts = record.split("=");
            if (parts.length > 1) {
              let baseUrl = parts[1];
              if (baseUrl.endsWith("/")) {
                baseUrl = baseUrl.slice(0, -1);
              }
              result.push(`https://${baseUrl}${path}`);
            }
          }
          return result;
        });
      }
      _pickNewFallbackUrl(currentFallbackInfo, urls) {
        var _a;
        if (urls == null) {
          return null;
        }
        const previouslyUsed = new Set((_a = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.previous) !== null && _a !== void 0 ? _a : []);
        const currentFallbackUrl = currentFallbackInfo === null || currentFallbackInfo === void 0 ? void 0 : currentFallbackInfo.url;
        let found = null;
        for (const loopUrl of urls) {
          const url = loopUrl.endsWith("/") ? loopUrl.slice(0, -1) : loopUrl;
          if (!previouslyUsed.has(loopUrl) && url !== currentFallbackUrl) {
            found = url;
            break;
          }
        }
        return found;
      }
    };
    exports.NetworkFallbackResolver = NetworkFallbackResolver;
    function _isDomainFailure(errorMsg, timedOut) {
      var _a;
      const lowerErrorMsg = (_a = errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.toLowerCase()) !== null && _a !== void 0 ? _a : "";
      return timedOut || lowerErrorMsg.includes("uncaught exception") || lowerErrorMsg.includes("failed to fetch") || lowerErrorMsg.includes("networkerror when attempting to fetch resource");
    }
    exports._isDomainFailure = _isDomainFailure;
    function _getFallbackInfoStorageKey(sdkKey) {
      return `statsig.network_fallback.${(0, Hashing_1._DJB2)(sdkKey)}`;
    }
    function _tryWriteFallbackInfoToCache(sdkKey, info) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      if (!info || Object.keys(info).length === 0) {
        StorageProvider_1.Storage.removeItem(hashKey);
        return;
      }
      StorageProvider_1.Storage.setItem(hashKey, JSON.stringify(info));
    }
    function _readFallbackInfoFromCache(sdkKey) {
      const hashKey = _getFallbackInfoStorageKey(sdkKey);
      const data = StorageProvider_1.Storage.getItem(hashKey);
      if (!data) {
        return null;
      }
      try {
        return JSON.parse(data);
      } catch (_a) {
        Log_1.Log.error("Failed to parse FallbackInfo");
        return null;
      }
    }
    function _extractPathFromUrl(urlString) {
      try {
        const url = new URL(urlString);
        return url.pathname;
      } catch (error) {
        return null;
      }
    }
  }
});

// node_modules/@statsig/client-core/src/SDKFlags.js
var require_SDKFlags = __commonJS({
  "node_modules/@statsig/client-core/src/SDKFlags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDKFlags = void 0;
    var FLAGMAP = {};
    exports.SDKFlags = {
      setFlags: (sdkKey, flags) => {
        FLAGMAP[sdkKey] = flags;
      },
      get: (sdkKey, flagKey) => {
        var _a, _b;
        return (_b = (_a = FLAGMAP[sdkKey]) === null || _a === void 0 ? void 0 : _a[flagKey]) !== null && _b !== void 0 ? _b : false;
      }
    };
  }
});

// node_modules/@statsig/client-core/src/SessionID.js
var require_SessionID = __commonJS({
  "node_modules/@statsig/client-core/src/SessionID.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigSession = exports.SessionID = void 0;
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var CacheKey_1 = require_CacheKey();
    var Log_1 = require_Log();
    var StorageProvider_1 = require_StorageProvider();
    var UUID_1 = require_UUID();
    var MAX_SESSION_IDLE_TIME = 30 * 60 * 1e3;
    var MAX_SESSION_AGE = 4 * 60 * 60 * 1e3;
    var PROMISE_MAP = {};
    exports.SessionID = {
      get: (sdkKey) => {
        return exports.StatsigSession.get(sdkKey).data.sessionID;
      }
    };
    exports.StatsigSession = {
      get: (sdkKey) => {
        if (PROMISE_MAP[sdkKey] == null) {
          PROMISE_MAP[sdkKey] = _loadSession(sdkKey);
        }
        const session = PROMISE_MAP[sdkKey];
        return _bumpSession(session);
      },
      overrideInitialSessionID: (override, sdkKey) => {
        PROMISE_MAP[sdkKey] = _overrideSessionId(override, sdkKey);
      }
    };
    function _loadSession(sdkKey) {
      let data = _loadFromStorage(sdkKey);
      const now = Date.now();
      if (!data) {
        data = {
          sessionID: (0, UUID_1.getUUID)(),
          startTime: now,
          lastUpdate: now
        };
      }
      return {
        data,
        sdkKey
      };
    }
    function _overrideSessionId(override, sdkKey) {
      const now = Date.now();
      return {
        data: {
          sessionID: override,
          startTime: now,
          lastUpdate: now
        },
        sdkKey
      };
    }
    function _bumpSession(session) {
      const now = Date.now();
      const data = session.data;
      const sdkKey = session.sdkKey;
      if (_isIdle(data) || _hasRunTooLong(data)) {
        data.sessionID = (0, UUID_1.getUUID)();
        data.startTime = now;
        const client = __STATSIG__ === null || __STATSIG__ === void 0 ? void 0 : __STATSIG__.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }
      data.lastUpdate = now;
      _persistToStorage(data, session.sdkKey);
      clearTimeout(session.idleTimeoutID);
      clearTimeout(session.ageTimeoutID);
      const lifetime = now - data.startTime;
      session.idleTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_IDLE_TIME);
      session.ageTimeoutID = _createSessionTimeout(sdkKey, MAX_SESSION_AGE - lifetime);
      return session;
    }
    function _createSessionTimeout(sdkKey, duration) {
      return setTimeout(() => {
        var _a;
        const client = (_a = (0, __StatsigGlobal_1._getStatsigGlobal)()) === null || _a === void 0 ? void 0 : _a.instance(sdkKey);
        if (client) {
          client.$emt({ name: "session_expired" });
        }
      }, duration);
    }
    function _isIdle({ lastUpdate }) {
      return Date.now() - lastUpdate > MAX_SESSION_IDLE_TIME;
    }
    function _hasRunTooLong({ startTime }) {
      return Date.now() - startTime > MAX_SESSION_AGE;
    }
    function _getSessionIDStorageKey(sdkKey) {
      return `statsig.session_id.${(0, CacheKey_1._getStorageKey)(sdkKey)}`;
    }
    function _persistToStorage(session, sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      try {
        (0, StorageProvider_1._setObjectInStorage)(storageKey, session);
      } catch (e) {
        Log_1.Log.warn("Failed to save SessionID");
      }
    }
    function _loadFromStorage(sdkKey) {
      const storageKey = _getSessionIDStorageKey(sdkKey);
      return (0, StorageProvider_1._getObjectFromStorage)(storageKey);
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js
var require_StatsigClientEventEmitter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientEventEmitter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorTag = void 0;
    exports.ErrorTag = {
      NetworkError: "NetworkError"
    };
  }
});

// node_modules/@statsig/client-core/src/NetworkCore.js
var require_NetworkCore = __commonJS({
  "node_modules/@statsig/client-core/src/NetworkCore.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NetworkCore = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    var Log_1 = require_Log();
    var NetworkConfig_1 = require_NetworkConfig();
    var NetworkFallbackResolver_1 = require_NetworkFallbackResolver();
    var SDKFlags_1 = require_SDKFlags();
    var SDKType_1 = require_SDKType();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StatsigClientEventEmitter_1 = require_StatsigClientEventEmitter();
    var StatsigMetadata_1 = require_StatsigMetadata();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var VisibilityObserving_1 = require_VisibilityObserving();
    var DEFAULT_TIMEOUT_MS = 1e4;
    var BACKOFF_BASE_MS = 500;
    var BACKOFF_MAX_MS = 3e4;
    var RATE_LIMIT_WINDOW_MS = 1e3;
    var RATE_LIMIT_MAX_REQ_COUNT = 50;
    var LEAK_RATE = RATE_LIMIT_MAX_REQ_COUNT / RATE_LIMIT_WINDOW_MS;
    var RETRYABLE_CODES = /* @__PURE__ */ new Set([408, 500, 502, 503, 504, 522, 524, 599]);
    var NetworkCore = class {
      constructor(options, _emitter) {
        this._emitter = _emitter;
        this._errorBoundary = null;
        this._timeout = DEFAULT_TIMEOUT_MS;
        this._netConfig = {};
        this._options = {};
        this._leakyBucket = {};
        this._lastUsedInitUrl = null;
        if (options) {
          this._options = options;
        }
        if (this._options.networkConfig) {
          this._netConfig = this._options.networkConfig;
        }
        if (this._netConfig.networkTimeoutMs) {
          this._timeout = this._netConfig.networkTimeoutMs;
        }
        this._fallbackResolver = new NetworkFallbackResolver_1.NetworkFallbackResolver(this._options);
        this.setLogEventCompressionMode(this._getLogEventCompressionMode(options));
      }
      setLogEventCompressionMode(mode) {
        this._options.logEventCompressionMode = mode;
      }
      setErrorBoundary(errorBoundary) {
        this._errorBoundary = errorBoundary;
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(this._fallbackResolver);
        this._fallbackResolver.setErrorBoundary(errorBoundary);
      }
      isBeaconSupported() {
        return typeof navigator !== "undefined" && typeof navigator.sendBeacon === "function";
      }
      getLastUsedInitUrlAndReset() {
        const tempUrl = this._lastUsedInitUrl;
        this._lastUsedInitUrl = null;
        return tempUrl;
      }
      beacon(args) {
        if (!_ensureValidSdkKey(args)) {
          return false;
        }
        const argsInternal = this._getInternalRequestArgs("POST", args);
        const url = this._getPopulatedURL(argsInternal);
        const nav = navigator;
        return nav.sendBeacon.bind(nav)(url, argsInternal.body);
      }
      post(args) {
        return __awaiter(this, void 0, void 0, function* () {
          const argsInternal = this._getInternalRequestArgs("POST", args);
          this._tryEncodeBody(argsInternal);
          yield this._tryToCompressBody(argsInternal);
          return this._sendRequest(argsInternal);
        });
      }
      get(args) {
        const argsInternal = this._getInternalRequestArgs("GET", args);
        return this._sendRequest(argsInternal);
      }
      _sendRequest(args) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c, _d;
          if (!_ensureValidSdkKey(args)) {
            return null;
          }
          if (this._netConfig.preventAllNetworkTraffic) {
            return null;
          }
          const { method, body, retries, attempt } = args;
          const endpoint = args.urlConfig.endpoint;
          if (this._isRateLimited(endpoint)) {
            Log_1.Log.warn(`Request to ${endpoint} was blocked because you are making requests too frequently.`);
            return null;
          }
          const currentAttempt = attempt !== null && attempt !== void 0 ? attempt : 1;
          let reqTimedOut = false;
          const populatedUrl = this._getPopulatedURL(args);
          let response = null;
          const keepalive = (0, VisibilityObserving_1._isUnloading)();
          try {
            const config = {
              method,
              body,
              headers: Object.assign({}, args.headers),
              priority: args.priority,
              keepalive
            };
            _tryMarkInitStart(args, currentAttempt);
            const bucket = this._leakyBucket[endpoint];
            if (bucket) {
              bucket.lastRequestTime = Date.now();
              this._leakyBucket[endpoint] = bucket;
            }
            const func = (_a = this._netConfig.networkOverrideFunc) !== null && _a !== void 0 ? _a : fetch;
            let timeoutId;
            response = yield Promise.race([
              func(populatedUrl, config).finally(() => clearTimeout(timeoutId)),
              new Promise((_, reject) => {
                timeoutId = setTimeout(() => {
                  reqTimedOut = true;
                  reject(new Error(`Timeout of ${this._timeout}ms expired.`));
                }, this._timeout);
              })
            ]);
            if (!response.ok) {
              const text2 = yield response.text().catch(() => "No Text");
              const err = new Error(`NetworkError: ${populatedUrl} ${text2}`);
              err.name = "NetworkError";
              throw err;
            }
            const text = yield response.text();
            _tryMarkInitEnd(args, response, currentAttempt, text);
            this._fallbackResolver.tryBumpExpiryTime(args.sdkKey, args.urlConfig);
            return {
              body: text,
              code: response.status
            };
          } catch (error) {
            const errorMessage = _getErrorMessage(error);
            const timedOut = _didTimeout(errorMessage !== null && errorMessage !== void 0 ? errorMessage : "", reqTimedOut);
            _tryMarkInitEnd(args, response, currentAttempt, "", error);
            const fallbackUpdated = yield this._fallbackResolver.tryFetchUpdatedFallbackInfo(args.sdkKey, args.urlConfig, errorMessage, timedOut);
            if (fallbackUpdated) {
              args.fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
            }
            if (!retries || currentAttempt > retries || !RETRYABLE_CODES.has((_b = response === null || response === void 0 ? void 0 : response.status) !== null && _b !== void 0 ? _b : 500)) {
              (_c = this._emitter) === null || _c === void 0 ? void 0 : _c.call(this, {
                name: "error",
                error,
                tag: StatsigClientEventEmitter_1.ErrorTag.NetworkError,
                requestArgs: args
              });
              const formattedErrorMsg = `A networking error occurred during ${method} request to ${populatedUrl}.`;
              Log_1.Log.error(formattedErrorMsg, errorMessage, error);
              (_d = this._errorBoundary) === null || _d === void 0 ? void 0 : _d.attachErrorIfNoneExists(formattedErrorMsg);
              return null;
            }
            yield _exponentialBackoff(currentAttempt);
            return this._sendRequest(Object.assign(Object.assign({}, args), { retries, attempt: currentAttempt + 1 }));
          }
        });
      }
      _getLogEventCompressionMode(options) {
        let compressionMode = options === null || options === void 0 ? void 0 : options.logEventCompressionMode;
        if (!compressionMode && (options === null || options === void 0 ? void 0 : options.disableCompression) === true) {
          compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Disabled;
        }
        if (!compressionMode) {
          compressionMode = StatsigOptionsCommon_1.LogEventCompressionMode.Enabled;
        }
        return compressionMode;
      }
      _isRateLimited(endpoint) {
        var _a;
        const now = Date.now();
        const bucket = (_a = this._leakyBucket[endpoint]) !== null && _a !== void 0 ? _a : {
          count: 0,
          lastRequestTime: now
        };
        const elapsed = now - bucket.lastRequestTime;
        const leakedRequests = Math.floor(elapsed * LEAK_RATE);
        bucket.count = Math.max(0, bucket.count - leakedRequests);
        if (bucket.count >= RATE_LIMIT_MAX_REQ_COUNT) {
          return true;
        }
        bucket.count += 1;
        bucket.lastRequestTime = now;
        this._leakyBucket[endpoint] = bucket;
        return false;
      }
      _getPopulatedURL(args) {
        var _a;
        const url = (_a = args.fallbackUrl) !== null && _a !== void 0 ? _a : args.urlConfig.getUrl();
        if (args.urlConfig.endpoint === NetworkConfig_1.Endpoint._initialize || args.urlConfig.endpoint === NetworkConfig_1.Endpoint._download_config_specs) {
          this._lastUsedInitUrl = url;
        }
        const params = Object.assign({ [NetworkConfig_1.NetworkParam.SdkKey]: args.sdkKey, [NetworkConfig_1.NetworkParam.SdkType]: SDKType_1.SDKType._get(args.sdkKey), [NetworkConfig_1.NetworkParam.SdkVersion]: StatsigMetadata_1.SDK_VERSION, [NetworkConfig_1.NetworkParam.Time]: String(Date.now()), [NetworkConfig_1.NetworkParam.SessionID]: SessionID_1.SessionID.get(args.sdkKey) }, args.params);
        const query = Object.keys(params).map((key) => {
          return `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;
        }).join("&");
        return `${url}${query ? `?${query}` : ""}`;
      }
      _tryEncodeBody(args) {
        var _a;
        const win = (0, SafeJs_1._getWindowSafe)();
        const body = args.body;
        if (!args.isStatsigEncodable || this._options.disableStatsigEncoding || typeof body !== "string" || (0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-encode") != null || !(win === null || win === void 0 ? void 0 : win.btoa)) {
          return;
        }
        try {
          args.body = win.btoa(body).split("").reverse().join("");
          args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.StatsigEncoded]: "1" });
        } catch (e) {
          Log_1.Log.warn(`Request encoding failed for ${args.urlConfig.getUrl()}`, e);
        }
      }
      _tryToCompressBody(args) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const body = args.body;
          if (typeof body !== "string" || !_allowCompression(args, this._options)) {
            return;
          }
          try {
            const bytes = new TextEncoder().encode(body);
            const stream = new CompressionStream("gzip");
            const writer = stream.writable.getWriter();
            writer.write(bytes).catch(Log_1.Log.error);
            writer.close().catch(Log_1.Log.error);
            const reader = stream.readable.getReader();
            const chunks = [];
            let result;
            while (!(result = yield reader.read()).done) {
              chunks.push(result.value);
            }
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const combined = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
              combined.set(chunk, offset);
              offset += chunk.length;
            }
            args.body = combined;
            args.params = Object.assign(Object.assign({}, (_a = args.params) !== null && _a !== void 0 ? _a : {}), { [NetworkConfig_1.NetworkParam.IsGzipped]: "1" });
          } catch (e) {
            Log_1.Log.warn(`Request compression failed for ${args.urlConfig.getUrl()}`, e);
          }
        });
      }
      _getInternalRequestArgs(method, args) {
        const fallbackUrl = this._fallbackResolver.getActiveFallbackUrl(args.sdkKey, args.urlConfig);
        const result = Object.assign(Object.assign({}, args), {
          method,
          fallbackUrl
        });
        if ("data" in args) {
          _populateRequestBody(result, args.data);
        }
        return result;
      }
    };
    exports.NetworkCore = NetworkCore;
    var _ensureValidSdkKey = (args) => {
      if (!args.sdkKey) {
        Log_1.Log.warn("Unable to make request without an SDK key");
        return false;
      }
      return true;
    };
    var _populateRequestBody = (args, data) => {
      const { sdkKey, fallbackUrl } = args;
      const stableID = StableID_1.StableID.get(sdkKey);
      const sessionID = SessionID_1.SessionID.get(sdkKey);
      const sdkType = SDKType_1.SDKType._get(sdkKey);
      args.body = JSON.stringify(Object.assign(Object.assign({}, data), { statsigMetadata: Object.assign(Object.assign({}, StatsigMetadata_1.StatsigMetadataProvider.get()), {
        stableID,
        sessionID,
        sdkType,
        fallbackUrl
      }) }));
    };
    function _allowCompression(args, options) {
      if (!args.isCompressable) {
        return false;
      }
      if ((0, __StatsigGlobal_1._getStatsigGlobalFlag)("no-compress") != null || typeof CompressionStream === "undefined" || typeof TextEncoder === "undefined") {
        return false;
      }
      const isProxy = args.urlConfig.customUrl != null || args.urlConfig.fallbackUrls != null;
      const flagEnabled = SDKFlags_1.SDKFlags.get(args.sdkKey, "enable_log_event_compression") === true;
      switch (options.logEventCompressionMode) {
        case StatsigOptionsCommon_1.LogEventCompressionMode.Disabled:
          return false;
        case StatsigOptionsCommon_1.LogEventCompressionMode.Enabled:
          if (isProxy && !flagEnabled) {
            return false;
          }
          return true;
        case StatsigOptionsCommon_1.LogEventCompressionMode.Forced:
          return true;
        default:
          return false;
      }
    }
    function _getErrorMessage(error) {
      if (typeof error === "string") {
        return error;
      }
      if (error instanceof Error) {
        return `${error.name}: ${error.message}`;
      }
      return "Unknown Error";
    }
    function _didTimeout(errorMsg, abortedByTimeout) {
      const timeout = errorMsg.includes("Timeout");
      return timeout || abortedByTimeout;
    }
    function _tryMarkInitStart(args, attempt) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqStart(args.sdkKey, {
        attempt
      });
    }
    function _tryMarkInitEnd(args, response, attempt, body, err) {
      if (args.urlConfig.endpoint !== NetworkConfig_1.Endpoint._initialize) {
        return;
      }
      Diagnostics_1.Diagnostics._markInitNetworkReqEnd(args.sdkKey, Diagnostics_1.Diagnostics._getDiagnosticsData(response, attempt, body, err));
    }
    function _exponentialBackoff(attempt) {
      return __awaiter(this, void 0, void 0, function* () {
        yield new Promise((r) => setTimeout(r, Math.min(BACKOFF_BASE_MS * (attempt * attempt), BACKOFF_MAX_MS)));
      });
    }
  }
});

// node_modules/@statsig/client-core/src/OverrideAdapter.js
var require_OverrideAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/OverrideAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/ParamStoreTypes.js
var require_ParamStoreTypes = __commonJS({
  "node_modules/@statsig/client-core/src/ParamStoreTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/SizeOf.js
var require_SizeOf = __commonJS({
  "node_modules/@statsig/client-core/src/SizeOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._fastApproxSizeOf = void 0;
    var CURLY_AND_SQUARE_BRACKET_SIZE = 2;
    var APPROX_ADDITIONAL_SIZE = 1;
    var _fastApproxSizeOf = (obj, max) => {
      let size = 0;
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        size += key.length;
        if (typeof value === "object" && value !== null) {
          size += (0, exports._fastApproxSizeOf)(value, max) + CURLY_AND_SQUARE_BRACKET_SIZE;
        } else {
          size += String(value).length + APPROX_ADDITIONAL_SIZE;
        }
        if (size >= max) {
          return size;
        }
      }
      return size;
    };
    exports._fastApproxSizeOf = _fastApproxSizeOf;
  }
});

// node_modules/@statsig/client-core/src/StatsigClientBase.js
var require_StatsigClientBase = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigClientBase.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClientBase = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var ErrorBoundary_1 = require_ErrorBoundary();
    var EventLogger_1 = require_EventLogger();
    var Log_1 = require_Log();
    var MemoKey_1 = require_MemoKey();
    var SafeJs_1 = require_SafeJs();
    var SessionID_1 = require_SessionID();
    var StableID_1 = require_StableID();
    var StatsigOptionsCommon_1 = require_StatsigOptionsCommon();
    var StorageProvider_1 = require_StorageProvider();
    var MAX_MEMO_CACHE_SIZE = 3e3;
    var StatsigClientBase = class {
      constructor(sdkKey, adapter, network, options) {
        var _a, _b, _c, _d;
        this.loadingStatus = "Uninitialized";
        this._initializePromise = null;
        this._listeners = {};
        const emitter = this.$emt.bind(this);
        (options === null || options === void 0 ? void 0 : options.logLevel) != null && (Log_1.Log.level = options.logLevel);
        (options === null || options === void 0 ? void 0 : options.disableStorage) && StorageProvider_1.Storage._setDisabled(true);
        (options === null || options === void 0 ? void 0 : options.initialSessionID) && SessionID_1.StatsigSession.overrideInitialSessionID(options.initialSessionID, sdkKey);
        (options === null || options === void 0 ? void 0 : options.storageProvider) && StorageProvider_1.Storage._setProvider(options.storageProvider);
        (options === null || options === void 0 ? void 0 : options.enableCookies) && StableID_1.StableID._setCookiesEnabled(sdkKey, options.enableCookies);
        (options === null || options === void 0 ? void 0 : options.disableStableID) && StableID_1.StableID._setDisabled(sdkKey, true);
        this._sdkKey = sdkKey;
        this._options = options !== null && options !== void 0 ? options : {};
        this._memoCache = {};
        this.overrideAdapter = (_a = options === null || options === void 0 ? void 0 : options.overrideAdapter) !== null && _a !== void 0 ? _a : null;
        this._logger = new EventLogger_1.EventLogger(sdkKey, emitter, network, options);
        this._errorBoundary = new ErrorBoundary_1.ErrorBoundary(sdkKey, options, emitter);
        this._errorBoundary.wrap(this);
        this._errorBoundary.wrap(adapter);
        this._errorBoundary.wrap(this._logger);
        network.setErrorBoundary(this._errorBoundary);
        this.dataAdapter = adapter;
        this.dataAdapter.attach(sdkKey, options, network);
        this.storageProvider = StorageProvider_1.Storage;
        (_d = (_c = (_b = this.overrideAdapter) === null || _b === void 0 ? void 0 : _b.loadFromStorage) === null || _c === void 0 ? void 0 : _c.call(_b)) === null || _d === void 0 ? void 0 : _d.catch((e) => this._errorBoundary.logError("OA::loadFromStorage", e));
        this._primeReadyRipcord();
        _assignGlobalInstance(sdkKey, this);
      }
      /**
       * Updates runtime configuration options for the SDK, allowing toggling of certain behaviors such as logging and storage to comply with user preferences or regulations such as GDPR.
       *
       * @param {StatsigRuntimeMutableOptions} options - The configuration options that dictate the runtime behavior of the SDK.
       */
      updateRuntimeOptions(options) {
        if (options.loggingEnabled) {
          this._options.loggingEnabled = options.loggingEnabled;
          this._logger.setLoggingEnabled(options.loggingEnabled);
        } else if (options.disableLogging != null) {
          this._options.disableLogging = options.disableLogging;
          this._logger.setLoggingEnabled(options.disableLogging ? "disabled" : "browser-only");
        }
        if (options.disableStorage != null) {
          this._options.disableStorage = options.disableStorage;
          StorageProvider_1.Storage._setDisabled(options.disableStorage);
        }
        if (options.enableCookies != null) {
          this._options.enableCookies = options.enableCookies;
          StableID_1.StableID._setCookiesEnabled(this._sdkKey, options.enableCookies);
        }
        if (options.logEventCompressionMode) {
          this._logger.setLogEventCompressionMode(options.logEventCompressionMode);
        } else if (options.disableCompression) {
          this._logger.setLogEventCompressionMode(StatsigOptionsCommon_1.LogEventCompressionMode.Disabled);
        }
      }
      /**
       * Flushes any currently queued events.
       */
      flush() {
        return this._logger.flush();
      }
      /**
       * Gracefully shuts down the SDK, ensuring that all pending events are send before the SDK stops.
       * This function emits a 'pre_shutdown' event and then waits for the logger to complete its shutdown process.
       *
       * @returns {Promise<void>} A promise that resolves when all shutdown procedures, including logging shutdown, have been completed.
       */
      shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
          this.$emt({ name: "pre_shutdown" });
          this._setStatus("Uninitialized", null);
          this._initializePromise = null;
          yield this._logger.stop();
        });
      }
      /**
       * Subscribes a callback function to a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       * Once subscribed, the listener callback will be invoked whenever the specified event is emitted.
       *
       * @param {StatsigClientEventName} event - The name of the event to subscribe to, or '*' to subscribe to all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to execute when the event occurs. The function receives event-specific data as its parameter.
       * @see {@link off} for unsubscribing from events.
       */
      on(event, listener) {
        if (!this._listeners[event]) {
          this._listeners[event] = [];
        }
        this._listeners[event].push(listener);
      }
      /**
       * Unsubscribes a previously registered callback function from a specific {@link StatsigClientEvent} or all StatsigClientEvents if the wildcard '*' is used.
       *
       * @param {StatsigClientEventName} event - The name of the event from which to unsubscribe, or '*' to unsubscribe from all events.
       * @param {StatsigClientEventCallback<T>} listener - The callback function to remove from the event's notification list.
       * @see {@link on} for subscribing to events.
       */
      off(event, listener) {
        if (this._listeners[event]) {
          const index = this._listeners[event].indexOf(listener);
          if (index !== -1) {
            this._listeners[event].splice(index, 1);
          }
        }
      }
      $on(event, listener) {
        listener.__isInternal = true;
        this.on(event, listener);
      }
      $emt(event) {
        var _a;
        const barrier = (listener) => {
          try {
            listener(event);
          } catch (error) {
            if (listener.__isInternal === true) {
              this._errorBoundary.logError(`__emit:${event.name}`, error);
              return;
            }
            Log_1.Log.error(`An error occurred in a StatsigClientEvent listener. This is not an issue with Statsig.`, event);
          }
        };
        if (this._listeners[event.name]) {
          this._listeners[event.name].forEach((l) => barrier(l));
        }
        (_a = this._listeners["*"]) === null || _a === void 0 ? void 0 : _a.forEach(barrier);
      }
      _setStatus(newStatus, values) {
        this.loadingStatus = newStatus;
        this._memoCache = {};
        this.$emt({ name: "values_updated", status: newStatus, values });
      }
      _enqueueExposure(name, exposure, options) {
        if ((options === null || options === void 0 ? void 0 : options.disableExposureLog) === true) {
          this._logger.incrementNonExposureCount(name);
          return;
        }
        this._logger.enqueue(exposure);
      }
      _memoize(prefix, fn) {
        return (name, options) => {
          if (this._options.disableEvaluationMemoization) {
            return fn(name, options);
          }
          const memoKey = (0, MemoKey_1.createMemoKey)(prefix, name, options);
          if (!memoKey) {
            return fn(name, options);
          }
          if (!(memoKey in this._memoCache)) {
            if (Object.keys(this._memoCache).length >= MAX_MEMO_CACHE_SIZE) {
              this._memoCache = {};
            }
            this._memoCache[memoKey] = fn(name, options);
          }
          return this._memoCache[memoKey];
        };
      }
    };
    exports.StatsigClientBase = StatsigClientBase;
    function _assignGlobalInstance(sdkKey, client) {
      var _a;
      if ((0, SafeJs_1._isServerEnv)()) {
        return;
      }
      const statsigGlobal = (0, __StatsigGlobal_1._getStatsigGlobal)();
      const instances = (_a = statsigGlobal.instances) !== null && _a !== void 0 ? _a : {};
      const inst = client;
      if (instances[sdkKey] != null) {
        Log_1.Log.warn("Creating multiple Statsig clients with the same SDK key can lead to unexpected behavior. Multi-instance support requires different SDK keys.");
      }
      instances[sdkKey] = inst;
      if (!statsigGlobal.firstInstance) {
        statsigGlobal.firstInstance = inst;
      }
      statsigGlobal.instances = instances;
      __STATSIG__ = statsigGlobal;
    }
  }
});

// node_modules/@statsig/client-core/src/StatsigDataAdapter.js
var require_StatsigDataAdapter = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigDataAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataAdapterCachePrefix = void 0;
    exports.DataAdapterCachePrefix = "statsig.cached";
  }
});

// node_modules/@statsig/client-core/src/StatsigPlugin.js
var require_StatsigPlugin = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigPlugin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigTypeFactories.js
var require_StatsigTypeFactories = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypeFactories.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeTypedGet = exports._mergeOverride = exports._makeLayer = exports._makeExperiment = exports._makeDynamicConfig = exports._makeFeatureGate = void 0;
    var Log_1 = require_Log();
    var TypingUtils_1 = require_TypingUtils();
    function _makeEvaluation(name, details, evaluation, value) {
      var _a;
      return {
        name,
        details,
        ruleID: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.rule_id) !== null && _a !== void 0 ? _a : "",
        __evaluation: evaluation,
        value
      };
    }
    function _makeFeatureGate(name, details, evaluation) {
      var _a;
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, (evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) === true)), { idType: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.id_type) !== null && _a !== void 0 ? _a : null });
    }
    exports._makeFeatureGate = _makeFeatureGate;
    function _makeDynamicConfig(name, details, evaluation) {
      var _a, _b;
      const value = (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _a !== void 0 ? _a : {};
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, value)), { idType: (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.id_type) !== null && _b !== void 0 ? _b : null, get: _makeTypedGet2(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) });
    }
    exports._makeDynamicConfig = _makeDynamicConfig;
    function _makeExperiment(name, details, evaluation) {
      var _a;
      const result = _makeDynamicConfig(name, details, evaluation);
      return Object.assign(Object.assign({}, result), { groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null });
    }
    exports._makeExperiment = _makeExperiment;
    function _makeLayer2(name, details, evaluation, exposeFunc) {
      var _a, _b;
      return Object.assign(Object.assign({}, _makeEvaluation(name, details, evaluation, void 0)), { get: _makeTypedGet2(name, evaluation === null || evaluation === void 0 ? void 0 : evaluation.value, exposeFunc), groupName: (_a = evaluation === null || evaluation === void 0 ? void 0 : evaluation.group_name) !== null && _a !== void 0 ? _a : null, __value: (_b = evaluation === null || evaluation === void 0 ? void 0 : evaluation.value) !== null && _b !== void 0 ? _b : {} });
    }
    exports._makeLayer = _makeLayer2;
    function _mergeOverride(original, overridden, value, exposeFunc) {
      return Object.assign(Object.assign(Object.assign({}, original), overridden), { get: _makeTypedGet2(original.name, value, exposeFunc) });
    }
    exports._mergeOverride = _mergeOverride;
    function _makeTypedGet2(name, value, exposeFunc) {
      return (param, fallback) => {
        var _a;
        const found = (_a = value === null || value === void 0 ? void 0 : value[param]) !== null && _a !== void 0 ? _a : null;
        if (found == null) {
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        if (fallback != null && !(0, TypingUtils_1._isTypeMatch)(found, fallback)) {
          Log_1.Log.warn(`Parameter type mismatch. '${name}.${param}' was found to be type '${typeof found}' but fallback/return type is '${typeof fallback}'. See https://docs.statsig.com/client/javascript-sdk/#typed-getters`);
          return fallback !== null && fallback !== void 0 ? fallback : null;
        }
        exposeFunc === null || exposeFunc === void 0 ? void 0 : exposeFunc(param);
        return found;
      };
    }
    exports._makeTypedGet = _makeTypedGet2;
  }
});

// node_modules/@statsig/client-core/src/StatsigTypes.js
var require_StatsigTypes = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@statsig/client-core/src/StatsigUpdateDetails.js
var require_StatsigUpdateDetails = __commonJS({
  "node_modules/@statsig/client-core/src/StatsigUpdateDetails.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UPDATE_DETAIL_ERROR_MESSAGES = exports.createUpdateDetails = void 0;
    var createUpdateDetails = (success, source, initDuration, error, sourceUrl, warnings) => {
      return {
        duration: initDuration,
        source,
        success,
        error,
        sourceUrl,
        warnings
      };
    };
    exports.createUpdateDetails = createUpdateDetails;
    exports.UPDATE_DETAIL_ERROR_MESSAGES = {
      NO_NETWORK_DATA: "No data was returned from the network. This may be due to a network timeout if a timeout value was specified in the options or ad blocker error."
    };
  }
});

// node_modules/@statsig/client-core/src/index.js
var require_src = __commonJS({
  "node_modules/@statsig/client-core/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Storage = exports.Log = exports.EventLogger = exports.Diagnostics = void 0;
    require_StatsigGlobal();
    var __StatsigGlobal_1 = require_StatsigGlobal();
    var Diagnostics_1 = require_Diagnostics();
    Object.defineProperty(exports, "Diagnostics", { enumerable: true, get: function() {
      return Diagnostics_1.Diagnostics;
    } });
    var EventLogger_1 = require_EventLogger();
    Object.defineProperty(exports, "EventLogger", { enumerable: true, get: function() {
      return EventLogger_1.EventLogger;
    } });
    var Log_1 = require_Log();
    Object.defineProperty(exports, "Log", { enumerable: true, get: function() {
      return Log_1.Log;
    } });
    var StatsigMetadata_1 = require_StatsigMetadata();
    var StorageProvider_1 = require_StorageProvider();
    Object.defineProperty(exports, "Storage", { enumerable: true, get: function() {
      return StorageProvider_1.Storage;
    } });
    __exportStar(require_StatsigGlobal(), exports);
    __exportStar(require_CacheKey(), exports);
    __exportStar(require_ClientInterfaces(), exports);
    __exportStar(require_DataAdapterCore(), exports);
    __exportStar(require_Diagnostics(), exports);
    __exportStar(require_DownloadConfigSpecsResponse(), exports);
    __exportStar(require_ErrorBoundary(), exports);
    __exportStar(require_EvaluationOptions(), exports);
    __exportStar(require_EvaluationTypes(), exports);
    __exportStar(require_Hashing(), exports);
    __exportStar(require_InitializeResponse(), exports);
    __exportStar(require_Log(), exports);
    __exportStar(require_MemoKey(), exports);
    __exportStar(require_NetworkConfig(), exports);
    __exportStar(require_NetworkCore(), exports);
    __exportStar(require_OverrideAdapter(), exports);
    __exportStar(require_ParamStoreTypes(), exports);
    __exportStar(require_SafeJs(), exports);
    __exportStar(require_SDKType(), exports);
    __exportStar(require_SessionID(), exports);
    __exportStar(require_SizeOf(), exports);
    __exportStar(require_StableID(), exports);
    __exportStar(require_StatsigClientBase(), exports);
    __exportStar(require_StatsigClientEventEmitter(), exports);
    __exportStar(require_StatsigDataAdapter(), exports);
    __exportStar(require_StatsigEvent(), exports);
    __exportStar(require_StatsigMetadata(), exports);
    __exportStar(require_StatsigOptionsCommon(), exports);
    __exportStar(require_StatsigPlugin(), exports);
    __exportStar(require_StatsigTypeFactories(), exports);
    __exportStar(require_StatsigTypes(), exports);
    __exportStar(require_StatsigUser(), exports);
    __exportStar(require_StorageProvider(), exports);
    __exportStar(require_TypedJsonParse(), exports);
    __exportStar(require_TypingUtils(), exports);
    __exportStar(require_UrlConfiguration(), exports);
    __exportStar(require_UUID(), exports);
    __exportStar(require_VisibilityObserving(), exports);
    __exportStar(require_StatsigUpdateDetails(), exports);
    __exportStar(require_SDKFlags(), exports);
    Object.assign((0, __StatsigGlobal_1._getStatsigGlobal)(), { Log: Log_1.Log, SDK_VERSION: StatsigMetadata_1.SDK_VERSION });
  }
});

// node_modules/@statsig/js-client/src/V1InitializeContainer.js
var require_V1InitializeContainer = __commonJS({
  "node_modules/@statsig/js-client/src/V1InitializeContainer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V1InitializeContainer = void 0;
    var client_core_1 = require_src();
    var V1InitializeContainer = class {
      constructor(_values) {
        this._values = _values;
      }
      getGate(name) {
        return this._getResultFromLookup(this._values.feature_gates, name);
      }
      getConfig(name) {
        return this._getResultFromLookup(this._values.dynamic_configs, name);
      }
      getLayer(name) {
        return this._getResultFromLookup(this._values.layer_configs, name);
      }
      getParamStore(name) {
        return this._getResultFromLookup(this._values.param_stores, name);
      }
      getConfigList() {
        return Object.keys(this._values.dynamic_configs);
      }
      getExposureMapping() {
        return this._values.exposures;
      }
      _getResultFromLookup(lookup, name) {
        var _a, _b;
        if (!lookup) {
          return null;
        }
        return (_b = (_a = lookup[name]) !== null && _a !== void 0 ? _a : lookup[(0, client_core_1._DJB2)(name)]) !== null && _b !== void 0 ? _b : null;
      }
    };
    exports.V1InitializeContainer = V1InitializeContainer;
  }
});

// node_modules/@statsig/js-client/src/V2InitializeContainer.js
var require_V2InitializeContainer = __commonJS({
  "node_modules/@statsig/js-client/src/V2InitializeContainer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.V2InitializeContainer = void 0;
    var client_core_1 = require_src();
    var V2InitializeContainer = class {
      constructor(_values) {
        this._values = _values;
      }
      getGate(name) {
        var _a, _b, _c;
        const evalV2 = this._getResultFromLookup(this._values.feature_gates, name);
        if (!evalV2) {
          return null;
        }
        return {
          name,
          value: evalV2.v === true,
          rule_id: (_a = evalV2.r) !== null && _a !== void 0 ? _a : "default",
          secondary_exposures: (_b = evalV2.s) !== null && _b !== void 0 ? _b : [],
          id_type: (_c = evalV2.i) !== null && _c !== void 0 ? _c : ""
        };
      }
      getConfig(name) {
        var _a, _b, _c, _d;
        const evalV2 = this._getResultFromLookup(this._values.dynamic_configs, name);
        if (!evalV2) {
          return null;
        }
        return {
          name,
          value: (_a = this._values.values[evalV2.v]) !== null && _a !== void 0 ? _a : {},
          rule_id: evalV2.r,
          secondary_exposures: (_b = evalV2.s) !== null && _b !== void 0 ? _b : [],
          id_type: (_c = evalV2.i) !== null && _c !== void 0 ? _c : "",
          is_user_in_experiment: evalV2.ue === true ? true : false,
          passed: evalV2.p === true,
          group_name: (_d = evalV2.gn) !== null && _d !== void 0 ? _d : void 0,
          is_experiment_active: evalV2.ea === true ? true : false,
          group: evalV2.r,
          is_device_based: evalV2.i === "stableID"
        };
      }
      getLayer(name) {
        var _a, _b, _c, _d, _e, _f;
        const evalV2 = this._getResultFromLookup(this._values.layer_configs, name);
        if (!evalV2) {
          return null;
        }
        return {
          name,
          value: (_a = this._values.values[evalV2.v]) !== null && _a !== void 0 ? _a : {},
          rule_id: evalV2.r,
          secondary_exposures: (_b = evalV2.s) !== null && _b !== void 0 ? _b : [],
          is_user_in_experiment: evalV2.ue === true ? true : false,
          group_name: (_c = evalV2.gn) !== null && _c !== void 0 ? _c : void 0,
          is_experiment_active: evalV2.ea === true ? true : false,
          group: evalV2.r,
          is_device_based: evalV2.i === "stableID",
          allocated_experiment_name: (_d = evalV2.ae) !== null && _d !== void 0 ? _d : "",
          explicit_parameters: (_e = evalV2.ep) !== null && _e !== void 0 ? _e : [],
          undelegated_secondary_exposures: (_f = evalV2.us) !== null && _f !== void 0 ? _f : [],
          parameter_rule_ids: evalV2.pr
        };
      }
      getParamStore(name) {
        return this._getResultFromLookup(this._values.param_stores, name);
      }
      getConfigList() {
        return Object.keys(this._values.dynamic_configs);
      }
      getExposureMapping() {
        return this._values.exposures;
      }
      _getResultFromLookup(lookup, name) {
        var _a, _b;
        if (!lookup) {
          return null;
        }
        return (_b = (_a = lookup[name]) !== null && _a !== void 0 ? _a : lookup[(0, client_core_1._DJB2)(name)]) !== null && _b !== void 0 ? _b : null;
      }
    };
    exports.V2InitializeContainer = V2InitializeContainer;
  }
});

// node_modules/@statsig/js-client/src/EvaluationStore.js
var require_EvaluationStore = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationStore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var V1InitializeContainer_1 = require_V1InitializeContainer();
    var V2InitializeContainer_1 = require_V2InitializeContainer();
    var EvaluationStore = class {
      constructor(_sdkKey) {
        this._sdkKey = _sdkKey;
        this._rawValues = null;
        this._values = null;
        this._source = "Uninitialized";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
        this._warnings = /* @__PURE__ */ new Set();
      }
      reset() {
        this._values = null;
        this._rawValues = null;
        this._source = "Loading";
        this._lcut = 0;
        this._receivedAt = 0;
        this._bootstrapMetadata = null;
        this._warnings.clear();
      }
      finalize() {
        if (this._values) {
          return;
        }
        this._source = "NoValues";
      }
      getValues() {
        return this._rawValues ? (0, client_core_1._typedJsonParse)(this._rawValues, "has_updates", "EvaluationStoreValues") : null;
      }
      setValues(result, user) {
        var _a, _b;
        if (!result) {
          return false;
        }
        const values = (0, client_core_1._typedJsonParse)(result.data, "has_updates", "EvaluationResponse");
        if (values == null) {
          return false;
        }
        this._source = result.source;
        if ((values === null || values === void 0 ? void 0 : values.has_updates) !== true) {
          return true;
        }
        const updatedLcut = (_a = values.time) !== null && _a !== void 0 ? _a : 0;
        if (updatedLcut < this._lcut) {
          return true;
        }
        this._rawValues = result.data;
        this._lcut = values.time;
        this._receivedAt = result.receivedAt;
        if (values.response_format === "init-v2") {
          this._values = new V2InitializeContainer_1.V2InitializeContainer(values);
        } else {
          this._values = new V1InitializeContainer_1.V1InitializeContainer(values);
        }
        this._bootstrapMetadata = this._extractBootstrapMetadata(result.source, values);
        if (result.source && values.user) {
          this._setWarningState(user, values);
        }
        client_core_1.SDKFlags.setFlags(this._sdkKey, (_b = values.sdk_flags) !== null && _b !== void 0 ? _b : {});
        return true;
      }
      getWarnings() {
        if (this._warnings.size === 0) {
          return void 0;
        }
        return Array.from(this._warnings);
      }
      getGate(name) {
        const res = this._values ? this._values.getGate(name) : null;
        return this._getDetailedStoreResult(res);
      }
      getConfig(name) {
        const res = this._values ? this._values.getConfig(name) : null;
        return this._getDetailedStoreResult(res);
      }
      getConfigList() {
        if (!this._values) {
          return [];
        }
        return this._values.getConfigList();
      }
      getLayer(name) {
        const res = this._values ? this._values.getLayer(name) : null;
        return this._getDetailedStoreResult(res);
      }
      getParamStore(name) {
        const res = this._values ? this._values.getParamStore(name) : null;
        return this._getDetailedStoreResult(res);
      }
      getSource() {
        return this._source;
      }
      getExposureMapping() {
        var _a;
        return (_a = this._values) === null || _a === void 0 ? void 0 : _a.getExposureMapping();
      }
      _extractBootstrapMetadata(source, values) {
        if (source !== "Bootstrap") {
          return null;
        }
        const bootstrapMetadata = {};
        if (values.user) {
          bootstrapMetadata.user = values.user;
        }
        if (values.sdkInfo) {
          bootstrapMetadata.generatorSDKInfo = values.sdkInfo;
        }
        bootstrapMetadata.lcut = values.time;
        return bootstrapMetadata;
      }
      _getDetailedStoreResult(result) {
        return {
          result,
          details: this._getDetails(result == null)
        };
      }
      _setWarningState(user, values) {
        var _a, _b;
        const stableID = client_core_1.StableID.get(this._sdkKey);
        if (((_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID) !== stableID && // don't throw if they're both undefined
        (((_b = user.customIDs) === null || _b === void 0 ? void 0 : _b.stableID) || stableID)) {
          this._warnings.add("StableIDMismatch");
          return;
        }
        if ("user" in values) {
          const bootstrapUser = values["user"];
          const userForComparison = Object.assign(Object.assign({}, user), { analyticsOnlyMetadata: void 0, privateAttributes: void 0 });
          if ((0, client_core_1._getFullUserHash)(userForComparison) !== (0, client_core_1._getFullUserHash)(bootstrapUser)) {
            this._warnings.add("PartialUserMatch");
          }
        }
      }
      getCurrentSourceDetails() {
        if (this._source === "Uninitialized" || this._source === "NoValues") {
          return { reason: this._source };
        }
        const sourceDetails = {
          reason: this._source,
          lcut: this._lcut,
          receivedAt: this._receivedAt
        };
        if (this._warnings.size > 0) {
          sourceDetails.warnings = Array.from(this._warnings);
        }
        return sourceDetails;
      }
      _getDetails(isUnrecognized) {
        var _a, _b;
        const sourceDetails = this.getCurrentSourceDetails();
        let reason = sourceDetails.reason;
        const warnings = (_a = sourceDetails.warnings) !== null && _a !== void 0 ? _a : [];
        if (this._source === "Bootstrap" && warnings.length > 0) {
          reason = reason + warnings[0];
        }
        if (reason !== "Uninitialized" && reason !== "NoValues") {
          const subreason = isUnrecognized ? "Unrecognized" : "Recognized";
          reason = `${reason}:${subreason}`;
        }
        const bootstrapMetadata = this._source === "Bootstrap" ? (_b = this._bootstrapMetadata) !== null && _b !== void 0 ? _b : void 0 : void 0;
        if (bootstrapMetadata) {
          sourceDetails.bootstrapMetadata = bootstrapMetadata;
        }
        return Object.assign(Object.assign({}, sourceDetails), { reason });
      }
    };
    exports.default = EvaluationStore;
  }
});

// node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js
var require_EvaluationResponseDeltas = __commonJS({
  "node_modules/@statsig/js-client/src/EvaluationResponseDeltas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._resolveDeltasResponse = void 0;
    var client_core_1 = require_src();
    var MAX_DELTAS_SORT_DEPTH = 2;
    function _resolveDeltasResponse(cache2, deltasString) {
      const deltas = (0, client_core_1._typedJsonParse)(deltasString, "checksum", "DeltasEvaluationResponse");
      if (!deltas) {
        return {
          hadBadDeltaChecksum: true
        };
      }
      const merged = _mergeDeltasIntoCache(cache2, deltas);
      const resolved = _handleDeletedEntries(merged);
      const actualChecksum = (0, client_core_1._DJB2Object)({
        feature_gates: resolved.feature_gates,
        dynamic_configs: resolved.dynamic_configs,
        layer_configs: resolved.layer_configs
      }, MAX_DELTAS_SORT_DEPTH);
      const isMatch = actualChecksum === deltas.checksumV2;
      if (!isMatch) {
        return {
          hadBadDeltaChecksum: true,
          badChecksum: actualChecksum,
          badMergedConfigs: resolved,
          badFullResponse: deltas.deltas_full_response
        };
      }
      return JSON.stringify(resolved);
    }
    exports._resolveDeltasResponse = _resolveDeltasResponse;
    function _mergeDeltasIntoCache(cache2, deltas) {
      return Object.assign(Object.assign(Object.assign({}, cache2), deltas), { feature_gates: Object.assign(Object.assign({}, cache2.feature_gates), deltas.feature_gates), layer_configs: Object.assign(Object.assign({}, cache2.layer_configs), deltas.layer_configs), dynamic_configs: Object.assign(Object.assign({}, cache2.dynamic_configs), deltas.dynamic_configs) });
    }
    function _handleDeletedEntries(deltas) {
      const result = deltas;
      _deleteEntriesInRecord(deltas.deleted_gates, result.feature_gates);
      delete result.deleted_gates;
      _deleteEntriesInRecord(deltas.deleted_configs, result.dynamic_configs);
      delete result.deleted_configs;
      _deleteEntriesInRecord(deltas.deleted_layers, result.layer_configs);
      delete result.deleted_layers;
      return result;
    }
    function _deleteEntriesInRecord(keys, values) {
      keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
        delete values[key];
      });
    }
  }
});

// node_modules/@statsig/js-client/src/Network.js
var require_Network = __commonJS({
  "node_modules/@statsig/js-client/src/Network.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationResponseDeltas_1 = require_EvaluationResponseDeltas();
    var StatsigNetwork = class extends client_core_1.NetworkCore {
      constructor(options, emitter) {
        super(options, emitter);
        const config = options === null || options === void 0 ? void 0 : options.networkConfig;
        this._option = options;
        this._initializeUrlConfig = new client_core_1.UrlConfiguration(client_core_1.Endpoint._initialize, config === null || config === void 0 ? void 0 : config.initializeUrl, config === null || config === void 0 ? void 0 : config.api, config === null || config === void 0 ? void 0 : config.initializeFallbackUrls);
      }
      fetchEvaluations(sdkKey, current, priority, user, isCacheValidFor204) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f;
          const cache2 = current ? (0, client_core_1._typedJsonParse)(current, "has_updates", "InitializeResponse") : null;
          let data = {
            user,
            hash: (_c = (_b = (_a = this._option) === null || _a === void 0 ? void 0 : _a.networkConfig) === null || _b === void 0 ? void 0 : _b.initializeHashAlgorithm) !== null && _c !== void 0 ? _c : "djb2",
            deltasResponseRequested: false,
            full_checksum: null
          };
          if (cache2 === null || cache2 === void 0 ? void 0 : cache2.has_updates) {
            const hasHashChanged = (cache2 === null || cache2 === void 0 ? void 0 : cache2.hash_used) !== ((_f = (_e = (_d = this._option) === null || _d === void 0 ? void 0 : _d.networkConfig) === null || _e === void 0 ? void 0 : _e.initializeHashAlgorithm) !== null && _f !== void 0 ? _f : "djb2");
            data = Object.assign(Object.assign({}, data), { sinceTime: isCacheValidFor204 && !hasHashChanged ? cache2.time : 0, previousDerivedFields: "derived_fields" in cache2 && isCacheValidFor204 ? cache2.derived_fields : {}, deltasResponseRequested: true, full_checksum: cache2.full_checksum, partialUserMatchSinceTime: !hasHashChanged ? cache2.time : 0 });
          }
          return this._fetchEvaluations(sdkKey, cache2, data, priority);
        });
      }
      _fetchEvaluations(sdkKey, cache2, data, priority) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a, _b;
          const response = yield this.post({
            sdkKey,
            urlConfig: this._initializeUrlConfig,
            data,
            retries: 2,
            isStatsigEncodable: true,
            priority
          });
          if ((response === null || response === void 0 ? void 0 : response.code) === 204) {
            return '{"has_updates": false}';
          }
          if ((response === null || response === void 0 ? void 0 : response.code) !== 200) {
            return (_a = response === null || response === void 0 ? void 0 : response.body) !== null && _a !== void 0 ? _a : null;
          }
          if ((cache2 === null || cache2 === void 0 ? void 0 : cache2.has_updates) !== true || ((_b = response.body) === null || _b === void 0 ? void 0 : _b.includes('"is_delta":true')) !== true || data.deltasResponseRequested !== true) {
            return response.body;
          }
          const result = (0, EvaluationResponseDeltas_1._resolveDeltasResponse)(cache2, response.body);
          if (typeof result === "string") {
            return result;
          }
          return this._fetchEvaluations(sdkKey, cache2, Object.assign(Object.assign(Object.assign({}, data), result), { deltasResponseRequested: false }), priority);
        });
      }
    };
    exports.default = StatsigNetwork;
  }
});

// node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js
var require_ParamStoreGetterFactory = __commonJS({
  "node_modules/@statsig/js-client/src/ParamStoreGetterFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._makeParamStoreGetter = void 0;
    var client_core_1 = require_src();
    var NO_EXPOSURE_OPT = {
      disableExposureLog: true
    };
    function _shouldLogExposure(options) {
      return options == null || options.disableExposureLog === false;
    }
    function _shouldReturnFallback(value, fallback) {
      return fallback != null && !(0, client_core_1._isTypeMatch)(value, fallback);
    }
    function _getMappedStaticValue(param, _options) {
      return param.value;
    }
    function _getMappedGateValue(client, param, options) {
      const gate = client.getFeatureGate(param.gate_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      if (gate.value) {
        return param.pass_value;
      }
      return param.fail_value;
    }
    function _getMappedDynamicConfigValue(client, param, fallback, options) {
      const config = client.getDynamicConfig(param.config_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = config.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _getMappedExperimentValue(client, param, fallback, options) {
      const experiment = client.getExperiment(param.experiment_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = experiment.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _getMappedLayerValue(client, param, fallback, options) {
      const layer = client.getLayer(param.layer_name, _shouldLogExposure(options) ? void 0 : NO_EXPOSURE_OPT);
      const value = layer.get(param.param_name);
      if (_shouldReturnFallback(value, fallback)) {
        return fallback;
      }
      return value;
    }
    function _makeParamStoreGetter(client, config, options) {
      return (paramName, fallback) => {
        if (config == null) {
          return fallback;
        }
        const param = config[paramName];
        if (param == null || fallback != null && (0, client_core_1._typeOf)(fallback) !== param.param_type) {
          return fallback;
        }
        switch (param.ref_type) {
          case "static":
            return _getMappedStaticValue(param, options);
          case "gate":
            return _getMappedGateValue(client, param, options);
          case "dynamic_config":
            return _getMappedDynamicConfigValue(client, param, fallback, options);
          case "experiment":
            return _getMappedExperimentValue(client, param, fallback, options);
          case "layer":
            return _getMappedLayerValue(client, param, fallback, options);
          default:
            return fallback;
        }
      };
    }
    exports._makeParamStoreGetter = _makeParamStoreGetter;
  }
});

// node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js
var require_StatsigEvaluationsDataAdapter = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigEvaluationsDataAdapter.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigEvaluationsDataAdapter = void 0;
    var client_core_1 = require_src();
    var Network_1 = require_Network();
    var StatsigEvaluationsDataAdapter = class extends client_core_1.DataAdapterCore {
      constructor() {
        super("EvaluationsDataAdapter", "evaluations");
        this._network = null;
        this._options = null;
      }
      attach(sdkKey, options, network) {
        super.attach(sdkKey, options, network);
        if (network !== null && network instanceof Network_1.default) {
          this._network = network;
        } else {
          this._network = new Network_1.default(options !== null && options !== void 0 ? options : {});
        }
      }
      getDataAsync(current, user, options) {
        return this._getDataAsyncImpl(current, (0, client_core_1._normalizeUser)(user, this._options), options);
      }
      prefetchData(user, options) {
        return this._prefetchDataImpl(user, options);
      }
      setData(data) {
        const values = (0, client_core_1._typedJsonParse)(data, "has_updates", "data");
        if (values && "user" in values) {
          super.setData(data, values.user);
        } else {
          client_core_1.Log.error("StatsigUser not found. You may be using an older server SDK version. Please upgrade your SDK or use setDataLegacy.");
        }
      }
      setDataLegacy(data, user) {
        super.setData(data, user);
      }
      _fetchFromNetwork(current, user, options, isCacheValidFor204) {
        return __awaiter(this, void 0, void 0, function* () {
          var _a;
          const result = yield (_a = this._network) === null || _a === void 0 ? void 0 : _a.fetchEvaluations(this._getSdkKey(), current, options === null || options === void 0 ? void 0 : options.priority, user, isCacheValidFor204);
          return result !== null && result !== void 0 ? result : null;
        });
      }
      _getCacheKey(user) {
        var _a;
        const key = (0, client_core_1._getStorageKey)(this._getSdkKey(), user, (_a = this._options) === null || _a === void 0 ? void 0 : _a.customUserCacheKeyFunc);
        return `${client_core_1.DataAdapterCachePrefix}.${this._cacheSuffix}.${key}`;
      }
      _isCachedResultValidFor204(result, user) {
        return result.fullUserHash != null && result.fullUserHash === (0, client_core_1._getFullUserHash)(user);
      }
    };
    exports.StatsigEvaluationsDataAdapter = StatsigEvaluationsDataAdapter;
  }
});

// node_modules/@statsig/js-client/src/StatsigClient.js
var require_StatsigClient = __commonJS({
  "node_modules/@statsig/js-client/src/StatsigClient.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var client_core_1 = require_src();
    var EvaluationStore_1 = require_EvaluationStore();
    var Network_1 = require_Network();
    var ParamStoreGetterFactory_1 = require_ParamStoreGetterFactory();
    var StatsigEvaluationsDataAdapter_1 = require_StatsigEvaluationsDataAdapter();
    var StatsigClient2 = class _StatsigClient extends client_core_1.StatsigClientBase {
      /**
       * Retrieves an instance of the StatsigClient based on the provided SDK key.
       *  If no SDK key is provided, the method returns the most recently created instance of the StatsigClient.
       *  The method ensures that each unique SDK key corresponds to a single instance of StatsigClient, effectively implementing a singleton pattern for each key.
       *  If no instance exists for the given SDK key, a new StatsigClient instance will be created and returned.
       *
       * @param {string} [sdkKey] - Optional. The SDK key used to identify a specific instance of the StatsigClient. If omitted, the method returns the last created instance.
       * @returns {StatsigClient} Returns the StatsigClient instance associated with the given SDK key, creating a new one if needed.
       */
      static instance(sdkKey) {
        const instance = (0, client_core_1._getStatsigGlobal)().instance(sdkKey);
        if (instance instanceof _StatsigClient) {
          return instance;
        }
        client_core_1.Log.warn((0, client_core_1._isServerEnv)() ? "StatsigClient.instance is not supported in server environments" : "Unable to find StatsigClient instance");
        return new _StatsigClient(sdkKey !== null && sdkKey !== void 0 ? sdkKey : "", {});
      }
      /**
       * StatsigClient constructor
       *
       * @param {string} sdkKey A Statsig client SDK key. eg "client-xyz123..."
       * @param {StatsigUser} user StatsigUser object containing various attributes related to a user.
       * @param {StatsigOptions | null} options StatsigOptions, used to customize the behavior of the SDK.
       */
      constructor(sdkKey, user, options = null) {
        var _a, _b;
        client_core_1.SDKType._setClientType(sdkKey, "javascript-client");
        const network = new Network_1.default(options, (e) => {
          this.$emt(e);
        });
        super(sdkKey, (_a = options === null || options === void 0 ? void 0 : options.dataAdapter) !== null && _a !== void 0 ? _a : new StatsigEvaluationsDataAdapter_1.StatsigEvaluationsDataAdapter(), network, options);
        this._possibleFirstTouchMetadata = {};
        this.getFeatureGate = this._memoize(client_core_1.MemoPrefix._gate, this._getFeatureGateImpl.bind(this));
        this.getDynamicConfig = this._memoize(client_core_1.MemoPrefix._dynamicConfig, this._getDynamicConfigImpl.bind(this));
        this.getExperiment = this._memoize(client_core_1.MemoPrefix._experiment, this._getExperimentImpl.bind(this));
        this.getConfigList = this._memoize(client_core_1.MemoPrefix._configList, this._getConfigListImpl.bind(this));
        this.getLayer = this._memoize(client_core_1.MemoPrefix._layer, this._getLayerImpl.bind(this));
        this.getParameterStore = this._memoize(client_core_1.MemoPrefix._paramStore, this._getParameterStoreImpl.bind(this));
        this._store = new EvaluationStore_1.default(sdkKey);
        this._network = network;
        this._user = this._configureUser(user, options);
        this._sdkInstanceID = (0, client_core_1.getUUID)();
        const plugins = (_b = options === null || options === void 0 ? void 0 : options.plugins) !== null && _b !== void 0 ? _b : [];
        for (const plugin of plugins) {
          plugin.bind(this);
        }
      }
      /**
       * Initializes the StatsigClient using cached values. This method sets up the client synchronously by utilizing previously cached values.
       * After initialization, cache values are updated in the background for future use, either in subsequent sessions or when `updateUser` is called.
       * This is useful for quickly starting with the last-known-good configurations while refreshing data to keep settings up-to-date.
       *
       * @see {@link initializeAsync} for the asynchronous version of this method.
       */
      initializeSync(options) {
        var _a;
        if (this.loadingStatus !== "Uninitialized") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), -1, null, null, ["MultipleInitializations", ...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []]);
        }
        this._logger.start();
        return this.updateUserSync(this._user, options);
      }
      /**
       * Initializes the StatsigClient asynchronously by first using cached values and then updating to the latest values from the network.
       * Once the network values are fetched, they replace the existing cached values. If this method's promise is not awaited,
       * there might be a transition from cached to network values during the session, which can affect consistency.
       * This method is useful when it's acceptable to begin with potentially stale data and switch to the latest configuration as it becomes available.
       *
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully initialized with the latest values from the network or a timeout (if set) is hit.
       * @see {@link initializeSync} for the synchronous version of this method.
       */
      initializeAsync(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._initializePromise) {
            return this._initializePromise;
          }
          this._initializePromise = this._initializeAsyncImpl(options);
          return this._initializePromise;
        });
      }
      /**
       * Synchronously updates the user in the Statsig client and switches the internal state to use cached values for the newly specified user.
       * After the initial switch to cached values, this method updates these values in the background, preparing them for future sessions or subsequent calls to updateUser.
       * This method ensures the client is quickly ready with available data.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @see {@link updateUserAsync} for the asynchronous version of this method.
       */
      updateUserSync(user, options) {
        const startTime = performance.now();
        try {
          return this._updateUserSyncImpl(user, options, startTime);
        } catch (e) {
          const err = e instanceof Error ? e : new Error(String(e));
          return this._createErrorUpdateDetails(err, startTime);
        }
      }
      _updateUserSyncImpl(user, options, startTime) {
        var _a;
        const warnings = [...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []];
        this._resetForUser(user);
        const result = this.dataAdapter.getDataSync(this._user);
        if (result == null) {
          warnings.push("NoCachedValues");
        }
        this._store.setValues(result, this._user);
        this._finalizeUpdate(result);
        const disable = options === null || options === void 0 ? void 0 : options.disableBackgroundCacheRefresh;
        if (disable === true || disable == null && (result === null || result === void 0 ? void 0 : result.source) === "Bootstrap") {
          return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
        }
        this._runPostUpdate(result !== null && result !== void 0 ? result : null, this._user);
        return (0, client_core_1.createUpdateDetails)(true, this._store.getSource(), performance.now() - startTime, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), warnings);
      }
      /**
       * Asynchronously updates the user in the Statsig client by initially using cached values and then fetching the latest values from the network.
       * When the latest values are fetched, they replace the cached values. If the promise returned by this method is not awaited,
       * the client's state may shift from cached to updated network values during the session, potentially affecting consistency.
       * This method is best used in scenarios where up-to-date configuration is critical and initial delays are acceptable.
       *
       * @param {StatsigUser} user - The new StatsigUser for which the client should update its internal state.
       * @param {AsyncUpdateOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {Promise<void>} A promise that resolves once the client is fully updated with the latest values from the network or a timeout (if set) is hit.
       * @see {@link updateUserSync} for the synchronous version of this method.
       */
      updateUserAsync(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          const startTime = performance.now();
          try {
            return yield this._updateUserAsyncImpl(user, options);
          } catch (e) {
            const err = e instanceof Error ? e : new Error(String(e));
            return this._createErrorUpdateDetails(err, startTime);
          }
        });
      }
      _updateUserAsyncImpl(user, options) {
        return __awaiter(this, void 0, void 0, function* () {
          this._resetForUser(user);
          const initiator = this._user;
          client_core_1.Diagnostics._markInitOverallStart(this._sdkKey);
          let result = this.dataAdapter.getDataSync(initiator);
          this._store.setValues(result, this._user);
          this._setStatus("Loading", result);
          result = yield this.dataAdapter.getDataAsync(result, initiator, options);
          if (initiator !== this._user) {
            return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), -1, new Error("User changed during update"), this._network.getLastUsedInitUrlAndReset());
          }
          let isUsingNetworkValues = false;
          if (result != null) {
            client_core_1.Diagnostics._markInitProcessStart(this._sdkKey);
            isUsingNetworkValues = this._store.setValues(result, this._user);
            client_core_1.Diagnostics._markInitProcessEnd(this._sdkKey, {
              success: isUsingNetworkValues
            });
          }
          this._finalizeUpdate(result);
          if (!isUsingNetworkValues) {
            this._errorBoundary.attachErrorIfNoneExists(client_core_1.UPDATE_DETAIL_ERROR_MESSAGES.NO_NETWORK_DATA);
            this.$emt({ name: "initialization_failure" });
          }
          client_core_1.Diagnostics._markInitOverallEnd(this._sdkKey, isUsingNetworkValues, this._store.getCurrentSourceDetails());
          const initDuration = client_core_1.Diagnostics._enqueueDiagnosticsEvent(this._user, this._logger, this._sdkKey, this._options);
          return (0, client_core_1.createUpdateDetails)(isUsingNetworkValues, this._store.getSource(), initDuration, this._errorBoundary.getLastSeenErrorAndReset(), this._network.getLastUsedInitUrlAndReset(), this._store.getWarnings());
        });
      }
      /**
       * Retrieves a synchronous context containing data currently being used by the SDK. Represented as a {@link PrecomputedEvaluationsContext} object.
       *
       * @returns {PrecomputedEvaluationsContext} The current synchronous context for the this StatsigClient instance.
       */
      getContext() {
        return {
          sdkKey: this._sdkKey,
          options: this._options,
          values: this._store.getValues(),
          user: JSON.parse(JSON.stringify(this._user)),
          errorBoundary: this._errorBoundary,
          session: client_core_1.StatsigSession.get(this._sdkKey),
          stableID: client_core_1.StableID.get(this._sdkKey),
          sdkInstanceID: this._sdkInstanceID
        };
      }
      /**
       * Retrieves the value of a feature gate for the current user, represented as a simple boolean.
       *
       * @param {string} name - The name of the feature gate to retrieve.
       * @param {FeatureGateEvaluationOptions} [options] - Optional. Additional options to customize the method call.
       * @returns {boolean} - The boolean value representing the gate's current evaluation results for the user.
       */
      checkGate(name, options) {
        return this.getFeatureGate(name, options).value;
      }
      /**
       * Logs an event to the internal logging system. This function allows logging by either passing a fully formed event object or by specifying the event name with optional value and metadata.
       *
       * @param {StatsigEvent|string} eventOrName - The event object conforming to the StatsigEvent interface, or the name of the event as a string.
       * @param {string|number} value - Optional. The value associated with the event, which can be a string or a number. This parameter is ignored if the first parameter is a StatsigEvent object.
       * @param {Record<string, string>} metadata - Optional. A key-value record containing metadata about the event. This is also ignored if the first parameter is an event object.
       */
      logEvent(eventOrName, value, metadata) {
        const event = typeof eventOrName === "string" ? {
          eventName: eventOrName,
          value,
          metadata
        } : eventOrName;
        this.$emt({
          name: "log_event_called",
          event
        });
        this._logger.enqueue(Object.assign(Object.assign({}, event), { user: this._user, time: Date.now() }));
      }
      /**
       * Updates the user with analytics only metadata. This will override any existing analytics only metadata.
       *
       * @param {Record<string, string | number | boolean>} metadata - The metadata to add to the user.
       */
      updateUserWithAnalyticsOnlyMetadata(metadata) {
        this._user = this._configureUser(Object.assign(Object.assign({}, this._user), { analyticsOnlyMetadata: metadata }), this._options);
      }
      _primeReadyRipcord() {
        this.$on("error", () => {
          this.loadingStatus === "Loading" && this._finalizeUpdate(null);
        });
      }
      _initializeAsyncImpl(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!client_core_1.Storage.isReady()) {
            yield client_core_1.Storage.isReadyResolver();
          }
          this._logger.start();
          return this.updateUserAsync(this._user, options);
        });
      }
      _createErrorUpdateDetails(error, startTime) {
        var _a;
        return (0, client_core_1.createUpdateDetails)(false, this._store.getSource(), performance.now() - startTime, error, null, [...(_a = this._store.getWarnings()) !== null && _a !== void 0 ? _a : []]);
      }
      _finalizeUpdate(values) {
        this._store.finalize();
        this._setStatus("Ready", values);
      }
      _runPostUpdate(current, user) {
        this.dataAdapter.getDataAsync(current, user, { priority: "low" }).catch((err) => {
          client_core_1.Log.error("An error occurred after update.", err);
        });
      }
      _resetForUser(user) {
        this._logger.reset();
        this._store.reset();
        this._user = this._configureUser(user, this._options);
      }
      _configureUser(originalUser, options) {
        var _a, _b, _c;
        const user = (0, client_core_1._normalizeUser)(originalUser, options);
        const stableIdOverride = (_a = user.customIDs) === null || _a === void 0 ? void 0 : _a.stableID;
        if (stableIdOverride) {
          const readyPromise = (_c = (_b = this.storageProvider).isReadyResolver) === null || _c === void 0 ? void 0 : _c.call(_b);
          if (readyPromise) {
            readyPromise.then(() => client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey), () => client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey));
          } else {
            client_core_1.StableID.setOverride(stableIdOverride, this._sdkKey);
          }
        }
        if (Object.keys(this._possibleFirstTouchMetadata).length > 0) {
          user.analyticsOnlyMetadata = Object.assign(Object.assign({}, user.analyticsOnlyMetadata), this._possibleFirstTouchMetadata);
        }
        return user;
      }
      _getFeatureGateImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getGate(name);
        const gate = (0, client_core_1._makeFeatureGate)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getGateOverride) === null || _b === void 0 ? void 0 : _b.call(_a, gate, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : gate;
        this._enqueueExposure(name, (0, client_core_1._createGateExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "gate_evaluation", gate: result });
        return result;
      }
      _getDynamicConfigImpl(name, options) {
        var _a, _b;
        const { result: evaluation, details } = this._store.getConfig(name);
        const config = (0, client_core_1._makeDynamicConfig)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getDynamicConfigOverride) === null || _b === void 0 ? void 0 : _b.call(_a, config, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : config;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "dynamic_config_evaluation", dynamicConfig: result });
        return result;
      }
      _getExperimentImpl(name, options) {
        var _a, _b, _c, _d;
        const { result: evaluation, details } = this._store.getConfig(name);
        const experiment = (0, client_core_1._makeExperiment)(name, details, evaluation);
        if (experiment.__evaluation != null) {
          experiment.__evaluation.secondary_exposures = (0, client_core_1._mapExposures)((_b = (_a = experiment.__evaluation) === null || _a === void 0 ? void 0 : _a.secondary_exposures) !== null && _b !== void 0 ? _b : [], this._store.getExposureMapping());
        }
        const overridden = (_d = (_c = this.overrideAdapter) === null || _c === void 0 ? void 0 : _c.getExperimentOverride) === null || _d === void 0 ? void 0 : _d.call(_c, experiment, this._user, options);
        const result = overridden !== null && overridden !== void 0 ? overridden : experiment;
        this._enqueueExposure(name, (0, client_core_1._createConfigExposure)(this._user, result, this._store.getExposureMapping()), options);
        this.$emt({ name: "experiment_evaluation", experiment: result });
        return result;
      }
      _getConfigListImpl() {
        return this._store.getConfigList();
      }
      _getLayerImpl(name, options) {
        var _a, _b, _c;
        const { result: evaluation, details } = this._store.getLayer(name);
        const layer = (0, client_core_1._makeLayer)(name, details, evaluation);
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getLayerOverride) === null || _b === void 0 ? void 0 : _b.call(_a, layer, this._user, options);
        if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
          this._logger.incrementNonExposureCount(name);
        }
        const result = (0, client_core_1._mergeOverride)(layer, overridden, (_c = overridden === null || overridden === void 0 ? void 0 : overridden.__value) !== null && _c !== void 0 ? _c : layer.__value, (param) => {
          if (options === null || options === void 0 ? void 0 : options.disableExposureLog) {
            return;
          }
          this._enqueueExposure(name, (0, client_core_1._createLayerParameterExposure)(this._user, result, param, this._store.getExposureMapping()), options);
        });
        this.$emt({ name: "layer_evaluation", layer: result });
        return result;
      }
      _getParameterStoreImpl(name, options) {
        var _a, _b;
        const { result: configuration, details } = this._store.getParamStore(name);
        this._logger.incrementNonExposureCount(name);
        const paramStore = {
          name,
          details,
          __configuration: configuration,
          get: (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, configuration, options)
        };
        const overridden = (_b = (_a = this.overrideAdapter) === null || _a === void 0 ? void 0 : _a.getParamStoreOverride) === null || _b === void 0 ? void 0 : _b.call(_a, paramStore, options);
        if (overridden != null) {
          paramStore.__configuration = overridden.config;
          paramStore.details = overridden.details;
          paramStore.get = (0, ParamStoreGetterFactory_1._makeParamStoreGetter)(this, overridden.config, options);
        }
        return paramStore;
      }
    };
    exports.default = StatsigClient2;
  }
});

// node_modules/@statsig/js-client/src/index.js
var require_src2 = __commonJS({
  "node_modules/@statsig/js-client/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatsigClient = void 0;
    var client_core_1 = require_src();
    var StatsigClient_1 = require_StatsigClient();
    exports.StatsigClient = StatsigClient_1.default;
    __exportStar(require_src(), exports);
    var __STATSIG__2 = Object.assign((0, client_core_1._getStatsigGlobal)(), {
      StatsigClient: StatsigClient_1.default
    });
    exports.default = __STATSIG__2;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}

// node_modules/@compiled/react/dist/esm/runtime/ax.js
var ATOMIC_GROUP_LENGTH = 5;
function ax(classNames) {
  if (!classNames.length) {
    return;
  }
  if (classNames.length === 1 && classNames[0] && // checking to see if `classNames[0]` is a string that contains other classnames
  !classNames[0].includes(" ")) {
    return classNames[0];
  }
  const map = {};
  for (const value of classNames) {
    if (!value) {
      continue;
    }
    const list = value.split(" ");
    for (const className of list) {
      const key = className.startsWith("_") ? className.slice(0, ATOMIC_GROUP_LENGTH) : className;
      map[key] = className;
    }
  }
  let result = "";
  for (const key in map) {
    result += map[key] + " ";
  }
  if (!result) {
    return;
  }
  return result.trimEnd();
}

// node_modules/@compiled/react/dist/esm/runtime/style.js
var import_react2 = __toESM(require_react());

// node_modules/@compiled/react/dist/esm/runtime/is-server-environment.js
var isJsDomEnvironment = () => window.name === "nodejs" || (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent.includes("Node.js")) || (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent.includes("jsdom"));
var isServerEnvironment = () => {
  if (typeof window === "undefined" || typeof process !== "undefined" && process.versions != null && process.versions.node != null) {
    return true;
  }
  if (isJsDomEnvironment()) {
    return true;
  }
  return false;
};

// node_modules/@compiled/react/dist/esm/runtime/style-cache.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var Cache = isServerEnvironment() ? (0, import_react.createContext)(null) : {};
if (!isServerEnvironment() && typeof document !== "undefined") {
  const ssrStyles = document.querySelectorAll("style[data-cmpld]");
  for (let i = 0; i < ssrStyles.length; i++) {
    document.head.appendChild(ssrStyles[i]);
  }
}

// node_modules/@compiled/react/dist/esm/runtime/ac.js
var UNDERSCORE_UNICODE = 95;
var ATOMIC_GROUP_LENGTH2 = 5;
var cache = /* @__PURE__ */ new Map();
var AtomicGroups = class {
  constructor(values) {
    this.values = values;
  }
  toString() {
    let str = "";
    for (const [, value] of this.values) {
      str += value + " ";
    }
    return str.slice(0, -1);
  }
};
function ac(classNames) {
  if (classNames.length <= 1 && !classNames[0])
    return void 0;
  const atomicGroups = /* @__PURE__ */ new Map();
  for (let i = 0; i < classNames.length; i++) {
    const cls = classNames[i];
    if (!cls) {
      continue;
    }
    if (typeof cls === "string") {
      const groups = cls.split(" ");
      for (let x = 0; x < groups.length; x++) {
        const atomic = groups[x];
        const isAtomic = atomic.charCodeAt(0) === UNDERSCORE_UNICODE;
        const isCompressed = isAtomic && atomic.charCodeAt(5) === UNDERSCORE_UNICODE;
        const atomicGroupName = isAtomic ? atomic.slice(0, ATOMIC_GROUP_LENGTH2) : atomic;
        atomicGroups.set(atomicGroupName, isCompressed ? atomic.slice(ATOMIC_GROUP_LENGTH2 + 1) : atomic);
      }
    } else {
      for (const [key, value] of cls.values) {
        atomicGroups.set(key, value);
      }
    }
  }
  return new AtomicGroups(atomicGroups);
}
function memoizedAc(classNames) {
  if (classNames.length <= 1 && !classNames[0])
    return void 0;
  let cacheKey = "";
  for (let i = 0; i < classNames.length; i += 1) {
    const current = classNames[i];
    if (!current)
      continue;
    cacheKey += current + " ";
  }
  cacheKey = cacheKey.slice(0, -1);
  if (cache.has(cacheKey))
    return cache.get(cacheKey);
  const result = ac(classNames);
  cache.set(cacheKey, result);
  return result;
}
var ac_default = isServerEnvironment() ? ac : memoizedAc;

// node_modules/@compiled/react/dist/esm/runtime/css-custom-property.js
function cssCustomPropertyValue(value, suffix, prefix) {
  if (value != void 0) {
    if (suffix) {
      if (prefix) {
        return prefix + value + suffix;
      }
      return value + suffix;
    }
    return value;
  }
  return "var(--c-, )";
}

// node_modules/@atlaskit/analytics-next/dist/esm/hooks/usePlatformLeafEventHandler.js
var import_react7 = __toESM(require_react());

// node_modules/use-memo-one/dist/use-memo-one.esm.js
var import_react3 = __toESM(require_react());
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (newInputs[i] !== lastInputs[i]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial = (0, import_react3.useState)(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = (0, import_react3.useRef)(true);
  var committed = (0, import_react3.useRef)(initial);
  var useCache2 = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
  var cache2 = useCache2 ? committed.current : {
    inputs,
    result: getResult()
  };
  (0, import_react3.useEffect)(function() {
    isFirstRun.current = false;
    committed.current = cache2;
  }, [cache2]);
  return cache2.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function() {
    return callback;
  }, inputs);
}

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
  return t;
}

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}

// node_modules/@atlaskit/analytics-next/dist/esm/events/AnalyticsEvent.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var AnalyticsEvent = function() {
  function AnalyticsEvent2(props) {
    var _this = this;
    _classCallCheck(this, AnalyticsEvent2);
    _defineProperty(this, "_isAnalyticsEvent", true);
    _defineProperty(this, "clone", function() {
      var payload = _objectSpread({}, _this.payload);
      return new AnalyticsEvent2({
        payload
      });
    });
    this.payload = props.payload;
  }
  return _createClass(AnalyticsEvent2, [{
    key: "update",
    value: function update(updater) {
      if (typeof updater === "function") {
        this.payload = updater(this.payload);
      }
      if (_typeof(updater) === "object") {
        this.payload = _objectSpread(_objectSpread({}, this.payload), updater);
      }
      return this;
    }
  }]);
}();

// node_modules/@atlaskit/analytics-next/dist/esm/events/UIAnalyticsEvent.js
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct5() {
    return !!t;
  })();
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function(t2) {
    return p.apply(e, t2);
  } : p;
}
var UIAnalyticsEvent = function(_AnalyticsEvent) {
  function UIAnalyticsEvent2(props) {
    var _this;
    _classCallCheck(this, UIAnalyticsEvent2);
    _this = _callSuper(this, UIAnalyticsEvent2, [props]);
    _defineProperty(_this, "_isUIAnalyticsEvent", true);
    _defineProperty(_this, "clone", function() {
      if (_this.hasFired) {
        if (!process.env.CI) {
          console.warn("Cannot clone an event after it's been fired.");
        }
        return null;
      }
      var context = _toConsumableArray(_this.context);
      var handlers = _toConsumableArray(_this.handlers);
      var payload = JSON.parse(JSON.stringify(_this.payload));
      return new UIAnalyticsEvent2({
        context,
        handlers,
        payload
      });
    });
    _defineProperty(_this, "fire", function(channel) {
      if (_this.hasFired) {
        if (!process.env.CI) {
          console.warn("Cannot fire an event twice.");
        }
        return;
      }
      _this.handlers.forEach(function(handler) {
        return handler(_this, channel);
      });
      _this.hasFired = true;
    });
    _this.context = props.context || [];
    _this.handlers = props.handlers || [];
    _this.hasFired = false;
    return _this;
  }
  _inherits(UIAnalyticsEvent2, _AnalyticsEvent);
  return _createClass(UIAnalyticsEvent2, [{
    key: "update",
    value: function update(updater) {
      if (this.hasFired) {
        if (!process.env.CI) {
          console.warn("Cannot update an event after it's been fired.");
        }
        return this;
      }
      return _superPropGet(UIAnalyticsEvent2, "update", this, 3)([updater]);
    }
  }]);
}(AnalyticsEvent);

// node_modules/@atlaskit/analytics-next/dist/esm/hooks/useAnalyticsContext.js
var import_react5 = __toESM(require_react());

// node_modules/@atlaskit/analytics-next/node_modules/@atlaskit/analytics-next-stable-react-context/dist/esm/context.js
var import_react4 = __toESM(require_react());
var AnalyticsNextContext = (0, import_react4.createContext)({
  getAtlaskitAnalyticsContext: function() {
    return [];
  },
  getAtlaskitAnalyticsEventHandlers: function() {
    return [];
  }
});
var context_default = AnalyticsNextContext;

// node_modules/@atlaskit/analytics-next/node_modules/@atlaskit/analytics-next-stable-react-context/dist/esm/index.js
var esm_default = context_default;

// node_modules/@atlaskit/analytics-next/dist/esm/hooks/useAnalyticsContext.js
var useAnalyticsContext = function useAnalyticsContext2() {
  return (0, import_react5.useContext)(esm_default);
};

// node_modules/@atlaskit/analytics-next/dist/esm/hooks/useAnalyticsEvents.js
function useAnalyticsEvents() {
  var analyticsContext = useAnalyticsContext();
  var createAnalyticsEvent = useCallbackOne(function(payload) {
    return new UIAnalyticsEvent({
      context: analyticsContext.getAtlaskitAnalyticsContext(),
      handlers: analyticsContext.getAtlaskitAnalyticsEventHandlers(),
      payload
    });
  }, [analyticsContext]);
  return {
    createAnalyticsEvent
  };
}

// node_modules/@atlaskit/analytics-next/dist/esm/hooks/useTrackedRef.js
var import_react6 = __toESM(require_react());
var useTrackedRef = function useTrackedRef2(value) {
  var ref = (0, import_react6.useRef)(value);
  ref.current = value;
  return ref;
};

// node_modules/@atlaskit/analytics-next/dist/esm/hooks/usePlatformLeafEventHandler.js
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function usePlatformLeafEventHandler(_ref) {
  var fn = _ref.fn, action = _ref.action, componentName = _ref.componentName, actionSubject = _ref.actionSubject, packageName = _ref.packageName, packageVersion = _ref.packageVersion, analyticsData = _ref.analyticsData;
  var _useAnalyticsEvents = useAnalyticsEvents(), createAnalyticsEvent = _useAnalyticsEvents.createAnalyticsEvent;
  var dataRef = useTrackedRef(analyticsData);
  var fnRef = useTrackedRef(fn);
  var handler = (0, import_react7.useCallback)(function(value) {
    var analyticsEvent = createAnalyticsEvent({
      action,
      actionSubject: actionSubject || componentName,
      attributes: {
        componentName,
        packageName,
        packageVersion
      }
    });
    var context = _objectSpread2({
      componentName,
      packageName,
      packageVersion
    }, dataRef.current);
    analyticsEvent.context.push(context);
    var clone = analyticsEvent.clone();
    if (clone) {
      clone.fire("atlaskit");
    }
    fnRef.current(value, analyticsEvent);
  }, [
    // These are strings and won't change
    action,
    componentName,
    actionSubject,
    packageName,
    packageVersion,
    // This function is memoized in the context
    createAnalyticsEvent,
    // these are a stable ref because of the useTrackedRef hook
    dataRef,
    fnRef
  ]);
  return handler;
}

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/Client.js
var import_regenerator3 = __toESM(require_regenerator());
var import_js_client2 = __toESM(require_src2());

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/subscriptions/Subscriptions.js
var import_eventemitter3 = __toESM(require_eventemitter3());
function ownKeys3(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var ALL_FEATURE_VALUES = "@all-features";
var Subscriptions = function() {
  function Subscriptions2() {
    _classCallCheck(this, Subscriptions2);
    _defineProperty(this, "eventToValue", /* @__PURE__ */ new Map());
    this.emitter = new import_eventemitter3.default();
  }
  return _createClass(Subscriptions2, [{
    key: "onGateUpdated",
    value: function onGateUpdated(gateName, callback, checkGate, options) {
      var _this = this;
      var value = checkGate(gateName, _objectSpread3(_objectSpread3({}, options), {}, {
        fireGateExposure: false
      }));
      if (this.eventToValue.get(callback) === void 0) {
        this.eventToValue.set(callback, value);
      }
      var wrapCallback = function wrapCallback2() {
        var value2 = checkGate(gateName, _objectSpread3(_objectSpread3({}, options), {}, {
          fireGateExposure: false
        }));
        var existingValue = _this.eventToValue.get(callback);
        if (existingValue !== value2) {
          _this.eventToValue.set(callback, value2);
          callback(value2);
        }
      };
      this.emitter.on(gateName, wrapCallback);
      return function() {
        _this.emitter.off(gateName, wrapCallback);
      };
    }
  }, {
    key: "onExperimentValueUpdated",
    value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback, getExperimentValue, options) {
      var _this2 = this;
      var experimentEventName = "".concat(experimentName, ".").concat(parameterName);
      var value = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread3(_objectSpread3({}, options), {}, {
        fireExperimentExposure: false
      }));
      if (this.eventToValue.get(callback) === void 0) {
        this.eventToValue.set(callback, value);
      }
      var wrapCallback = function wrapCallback2() {
        var value2 = getExperimentValue(experimentName, parameterName, defaultValue, _objectSpread3(_objectSpread3({}, options), {}, {
          fireExperimentExposure: false
        }));
        var existingValue = _this2.eventToValue.get(callback);
        if (existingValue !== value2) {
          _this2.eventToValue.set(callback, value2);
          callback(value2);
        }
      };
      this.emitter.on(experimentEventName, wrapCallback);
      return function() {
        _this2.emitter.off(experimentEventName, wrapCallback);
      };
    }
  }, {
    key: "onAnyUpdated",
    value: function onAnyUpdated(callback) {
      var _this3 = this;
      this.emitter.on(ALL_FEATURE_VALUES, callback);
      return function() {
        _this3.emitter.off(ALL_FEATURE_VALUES, callback);
      };
    }
  }, {
    key: "anyUpdated",
    value: function anyUpdated() {
      var _this4 = this;
      this.emitter.emit(ALL_FEATURE_VALUES);
      this.emitter.eventNames().filter(function(name) {
        return name !== ALL_FEATURE_VALUES;
      }).forEach(function(event) {
        _this4.emitter.emit(event);
      });
    }
  }]);
}();

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/constants/index.js
var FEDRAMP_MODERATE = "fedramp-moderate";
var COMMERCIAL = "commercial";
var FEDRAMP_FEDEX = "fedramp-fedex";
var STAGING = "stg";
var PRODUCTION = "prod";
var DEV = "dev";

// node_modules/@atlaskit/atlassian-context/dist/esm/services/host-based-lookup/is-fedramp/index.js
function isFedRamp() {
  var _global$location;
  var global2 = globalThis;
  var env = global2.MICROS_PERIMETER || global2.UNSAFE_ATL_CONTEXT_BOUNDARY;
  if (env) {
    return env === FEDRAMP_MODERATE;
  }
  var matches = (_global$location = global2.location) === null || _global$location === void 0 || (_global$location = _global$location.hostname) === null || _global$location === void 0 ? void 0 : _global$location.match(/atlassian-us-gov-mod\.(com|net)|atlassian-us-gov\.(com|net)|atlassian-fex\.(com|net)|atlassian-stg-fedm\.(com|net)/);
  return matches ? matches.length > 0 : false;
}

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/host-based-lookup/constants/domains.js
var domainMap = _defineProperty(_defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty({}, STAGING, "stg.atlassian.com"), PRODUCTION, "atlassian.com")), FEDRAMP_FEDEX, _defineProperty({}, STAGING, "atlassian-fex.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, STAGING, "stg.atlassian-us-gov-mod.com"), PRODUCTION, "atlassian-us-gov-mod.com"));
var fullDomainOverride = {
  analytics: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "analytics.atlassian.com")),
  // Marketing site
  confluence: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "confluence.atlassian.com")),
  // Atlassian design system documentation
  design: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "design.atlassian.com")),
  // Old staff intranet (now hello.atlassian.net)
  extranet: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "extranet.atlassian.com")),
  // Go links
  go: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "go.atlassian.com")),
  my: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "my.atlassian.com")),
  schema: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "schema.atlassian.com")),
  start: _defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty({}, PRODUCTION, "start.atlassian.com"), STAGING, "start.stg.atlassian.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, PRODUCTION, "start.atlassian-us-gov-mod.com"), STAGING, "start.stg.atlassian-us-gov-mod.com")),
  surveys: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "surveys.atlassian.com")),
  "wac-cdn": _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "wac-cdn.atlassian.com")),
  integrations: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "integrations.atlassian.com")),
  permalink: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "permalink.atlassian.com")),
  id: _defineProperty(_defineProperty({}, COMMERCIAL, _defineProperty(_defineProperty(_defineProperty({}, PRODUCTION, "id.atlassian.com"), STAGING, "id.stg.internal.atlassian.com"), DEV, "id.dev.internal.atlassian.com")), FEDRAMP_MODERATE, _defineProperty(_defineProperty({}, PRODUCTION, "id.atlassian-us-gov-mod.com"), STAGING, "id.stg.atlassian-us-gov-mod.com")),
  support: _defineProperty({}, COMMERCIAL, _defineProperty({}, PRODUCTION, "support.atlassian.com"))
};

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/index.js
var FEDRAMP_MODERATE2 = "fedramp-moderate";
var COMMERCIAL2 = "commercial";
var STAGING2 = "staging";
var PRODUCTION2 = "prod";
var DEV2 = "dev";

// node_modules/@atlaskit/atlassian-context/dist/esm/common/constants/domains.js
var fullDomainOverride2 = {
  id: _defineProperty(_defineProperty({}, COMMERCIAL2, _defineProperty(_defineProperty(_defineProperty({}, PRODUCTION2, "id.atlassian.com"), STAGING2, "id.stg.internal.atlassian.com"), DEV2, "id.dev.internal.atlassian.com")), FEDRAMP_MODERATE2, _defineProperty(_defineProperty({}, PRODUCTION2, "id.atlassian-us-gov-mod.com"), STAGING2, "id.stg.atlassian-us-gov-mod.com"))
};

// node_modules/@atlaskit/atlassian-context/dist/esm/services/generalized-domain-lookup/constants.js
var ReservedNameMapping = _defineProperty({}, COMMERCIAL2, ["home", "start", "id", "api", "admin", "auth", "bitbucket"]);
var AtlDomainMapping = _defineProperty({}, COMMERCIAL2, ["packages"]);
var isolatedCloudFunctions = _defineProperty({}, COMMERCIAL2, {
  isolatedCloudReservedNameDomain: function isolatedCloudReservedNameDomain(subdomain, isolatedCloudDomain2) {
    return "".concat(subdomain, ".").concat(isolatedCloudDomain2);
  },
  isolatedCloudAtlDomain: function isolatedCloudAtlDomain(subdomain, isolatedCloudDomain2) {
    return "".concat(subdomain, ".atl.").concat(isolatedCloudDomain2);
  },
  isolatedCloudVanityDomain: function isolatedCloudVanityDomain(subdomain, isolatedCloudDomain2) {
    return "".concat(subdomain, ".services.").concat(isolatedCloudDomain2);
  }
});
var nonIsolatedCloudFunctions = _defineProperty(_defineProperty({}, COMMERCIAL2, {
  defaultDomainEnding: function defaultDomainEnding(subdomain, envType) {
    switch (envType) {
      case PRODUCTION2:
        return "".concat(subdomain, ".atlassian.com");
      case STAGING2:
        return "".concat(subdomain, ".stg.atlassian.com");
      case DEV2:
        return "".concat(subdomain, ".dev.atlassian.com");
      default:
        console.warn("Cannot get non-isolated commercial domain for provided environment, ".concat(envType, " is unsupported"));
        return "";
    }
  }
}), FEDRAMP_MODERATE2, {
  defaultDomainEnding: function defaultDomainEnding2(subdomain, envType) {
    switch (envType) {
      case PRODUCTION2:
        return "".concat(subdomain, ".atlassian-us-gov-mod.com");
      case STAGING2:
        return "".concat(subdomain, ".stg.atlassian-us-gov-mod.com");
      default:
        console.warn("Cannot get fedramp-moderate domain for provided environment, ".concat(envType, " is unsupported"));
        return "";
    }
  }
});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/types.js
var EvaluationReason = function(EvaluationReason2) {
  EvaluationReason2["Error"] = "Error";
  EvaluationReason2["LocalOverride"] = "LocalOverride";
  EvaluationReason2["Unrecognized"] = "Unrecognized";
  EvaluationReason2["Uninitialized"] = "Uninitialized";
  EvaluationReason2["NetworkNotModified"] = "NetworkNotModified";
  EvaluationReason2["Network"] = "Network";
  EvaluationReason2["InvalidBootstrap"] = "InvalidBootstrap";
  EvaluationReason2["Bootstrap"] = "Bootstrap";
  EvaluationReason2["Cache"] = "Cache";
  EvaluationReason2["Unknown"] = "Unknown";
  return EvaluationReason2;
}({});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/types.js
var FeatureGateEnvironment = function(FeatureGateEnvironment2) {
  FeatureGateEnvironment2["Development"] = "development";
  FeatureGateEnvironment2["Staging"] = "staging";
  FeatureGateEnvironment2["Production"] = "production";
  return FeatureGateEnvironment2;
}({});
var PerimeterType = function(PerimeterType2) {
  PerimeterType2["COMMERCIAL"] = "commercial";
  PerimeterType2["FEDRAMP_MODERATE"] = "fedramp-moderate";
  return PerimeterType2;
}({});

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/utils.js
var _excluded = ["api", "disableCurrentPageLogging", "loggingIntervalMillis", "loggingBufferMaxSize", "localMode", "eventLoggingApi", "eventLoggingApiForRetries", "disableLocalStorage", "ignoreWindowUndefined", "disableAllLogging", "initTimeoutMs", "disableNetworkKeepalive", "overrideStableID", "disableErrorLogging", "disableAutoMetricsLogging"];
function ownKeys4(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys4(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var getOptionsWithDefaults = function getOptionsWithDefaults2(options) {
  return _objectSpread4({
    /**
     * If more federal PerimeterTypes are added in the future, this should be updated so
     * that isFedRamp() === true always returns the strictest perimeter.
     */
    perimeter: isFedRamp() ? PerimeterType.FEDRAMP_MODERATE : PerimeterType.COMMERCIAL
  }, options);
};
var shallowEquals = function shallowEquals2(objectA, objectB) {
  if (!objectA && !objectB) {
    return true;
  }
  if (!objectA || !objectB) {
    return false;
  }
  var aEntries = Object.entries(objectA);
  var bEntries = Object.entries(objectB);
  if (aEntries.length !== bEntries.length) {
    return false;
  }
  var ascendingKeyOrder = function ascendingKeyOrder2(_ref, _ref2) {
    var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
    var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
    return key1.localeCompare(key2);
  };
  aEntries.sort(ascendingKeyOrder);
  bEntries.sort(ascendingKeyOrder);
  for (var i = 0; i < aEntries.length; i++) {
    var _aEntries$i = _slicedToArray(aEntries[i], 2), aValue = _aEntries$i[1];
    var _bEntries$i = _slicedToArray(bEntries[i], 2), bValue = _bEntries$i[1];
    if (aValue !== bValue) {
      return false;
    }
  }
  return true;
};
var toStatsigUser = function toStatsigUser2(identifiers, customAttributes) {
  var user = {
    customIDs: identifiers,
    custom: customAttributes
  };
  if (identifiers.atlassianAccountId) {
    user.userID = identifiers.atlassianAccountId;
  }
  return user;
};
var migrateInitializationOptions = function migrateInitializationOptions2(options) {
  var api = options.api, disableCurrentPageLogging = options.disableCurrentPageLogging, loggingIntervalMillis = options.loggingIntervalMillis, loggingBufferMaxSize = options.loggingBufferMaxSize, localMode = options.localMode, eventLoggingApi = options.eventLoggingApi, eventLoggingApiForRetries = options.eventLoggingApiForRetries, disableLocalStorage = options.disableLocalStorage, ignoreWindowUndefined = options.ignoreWindowUndefined, disableAllLogging = options.disableAllLogging, _initTimeoutMs = options.initTimeoutMs, _disableNetworkKeepalive = options.disableNetworkKeepalive, _overrideStableID = options.overrideStableID, _disableErrorLogging = options.disableErrorLogging, _disableAutoMetricsLogging = options.disableAutoMetricsLogging, rest = _objectWithoutProperties(options, _excluded);
  return _objectSpread4(_objectSpread4({}, rest), {}, {
    networkConfig: {
      api,
      logEventUrl: eventLoggingApi ? eventLoggingApi + "rgstr" : void 0,
      logEventFallbackUrls: eventLoggingApiForRetries ? [eventLoggingApiForRetries] : void 0,
      preventAllNetworkTraffic: localMode || !ignoreWindowUndefined && typeof window === "undefined"
    },
    includeCurrentPageUrlWithEvents: !disableCurrentPageLogging,
    loggingIntervalMs: loggingIntervalMillis,
    loggingBufferMaxSize,
    disableStorage: disableLocalStorage === void 0 ? localMode : disableLocalStorage,
    disableLogging: disableAllLogging === void 0 ? localMode : disableAllLogging
  });
};
var evaluationReasonMappings = Object.entries(EvaluationReason).map(function(_ref5) {
  var _ref6 = _slicedToArray(_ref5, 2), key = _ref6[0], value = _ref6[1];
  return [key.toLowerCase(), value];
});
var migrateEvaluationDetails = function migrateEvaluationDetails2(details) {
  var _evaluationReasonMapp, _evaluationReasonMapp2, _details$receivedAt;
  var reasonLower = details.reason.toLowerCase();
  return {
    reason: (_evaluationReasonMapp = (_evaluationReasonMapp2 = evaluationReasonMappings.find(function(_ref7) {
      var _ref8 = _slicedToArray(_ref7, 1), key = _ref8[0];
      return reasonLower.includes(key);
    })) === null || _evaluationReasonMapp2 === void 0 ? void 0 : _evaluationReasonMapp2[1]) !== null && _evaluationReasonMapp !== void 0 ? _evaluationReasonMapp : EvaluationReason.Unknown,
    time: (_details$receivedAt = details.receivedAt) !== null && _details$receivedAt !== void 0 ? _details$receivedAt : Date.now()
  };
};
var migrateSecondaryExposures = function migrateSecondaryExposures2(secondaryExposures) {
  return secondaryExposures.map(function(exposure) {
    if (typeof exposure === "string") {
      return {
        gate: exposure
      };
    }
    return exposure;
  });
};

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/DynamicConfig.js
var DynamicConfig = function() {
  function DynamicConfig2(configName, configValue, ruleID, evaluationDetails) {
    var secondaryExposures = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
    var allocatedExperimentName = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "";
    var onDefaultValueFallback = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null;
    _classCallCheck(this, DynamicConfig2);
    this.value = configValue;
    this._name = configName;
    this._ruleID = ruleID;
    this._secondaryExposures = secondaryExposures;
    this._allocatedExperimentName = allocatedExperimentName;
    this._evaluationDetails = evaluationDetails;
    this._onDefaultValueFallback = onDefaultValueFallback;
  }
  return _createClass(DynamicConfig2, [{
    key: "get",
    value: function get(key, defaultValue, typeGuard) {
      var _this$_onDefaultValue2;
      var val = this.getValue(key, defaultValue);
      if (val == null) {
        return defaultValue;
      }
      var expectedType = Array.isArray(defaultValue) ? "array" : _typeof(defaultValue);
      var actualType = Array.isArray(val) ? "array" : _typeof(val);
      if (typeGuard) {
        var _this$_onDefaultValue;
        if (typeGuard(val)) {
          this.fireExposure(key);
          return val;
        }
        (_this$_onDefaultValue = this._onDefaultValueFallback) === null || _this$_onDefaultValue === void 0 || _this$_onDefaultValue.call(this, this, key, expectedType, actualType);
        return defaultValue;
      }
      if (defaultValue == null || expectedType === actualType) {
        this.fireExposure(key);
        return val;
      }
      (_this$_onDefaultValue2 = this._onDefaultValueFallback) === null || _this$_onDefaultValue2 === void 0 || _this$_onDefaultValue2.call(this, this, key, expectedType, actualType);
      return defaultValue;
    }
  }, {
    key: "getValue",
    value: function getValue(key, defaultValue) {
      if (key == null) {
        return this.value;
      }
      if (defaultValue == null) {
        defaultValue = null;
      }
      if (this.value[key] == null) {
        return defaultValue;
      }
      this.fireExposure(key);
      return this.value[key];
    }
  }, {
    key: "fireExposure",
    value: function fireExposure(key) {
      if (this.experiment) {
        this.experiment.get(key);
      }
    }
  }], [{
    key: "fromExperiment",
    value: function fromExperiment(experiment) {
      var _experiment$__evaluat, _experiment$__evaluat2, _experiment$groupName;
      var config = new DynamicConfig2(experiment.name, experiment.value, experiment.ruleID, migrateEvaluationDetails(experiment.details), migrateSecondaryExposures((_experiment$__evaluat = (_experiment$__evaluat2 = experiment.__evaluation) === null || _experiment$__evaluat2 === void 0 ? void 0 : _experiment$__evaluat2.secondary_exposures) !== null && _experiment$__evaluat !== void 0 ? _experiment$__evaluat : []), (_experiment$groupName = experiment.groupName) !== null && _experiment$groupName !== void 0 ? _experiment$groupName : void 0);
      config.experiment = experiment;
      return config;
    }
    /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
  }]);
}();

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/compat/Layer.js
var Layer = function() {
  function Layer2(name, layerValue, ruleID, evaluationDetails) {
    var logParameterFunction = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    var secondaryExposures = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
    var undelegatedSecondaryExposures = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : [];
    var allocatedExperimentName = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "";
    var explicitParameters = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : [];
    _classCallCheck(this, Layer2);
    this._logParameterFunction = logParameterFunction;
    this._name = name;
    this._value = JSON.parse(JSON.stringify(layerValue !== null && layerValue !== void 0 ? layerValue : {}));
    this._ruleID = ruleID !== null && ruleID !== void 0 ? ruleID : "";
    this._evaluationDetails = evaluationDetails;
    this._secondaryExposures = secondaryExposures;
    this._undelegatedSecondaryExposures = undelegatedSecondaryExposures;
    this._allocatedExperimentName = allocatedExperimentName;
    this._explicitParameters = explicitParameters;
  }
  return _createClass(Layer2, [{
    key: "get",
    value: function get(key, defaultValue, typeGuard) {
      var _this = this;
      var val = this._value[key];
      if (val == null) {
        return defaultValue;
      }
      var logAndReturn = function logAndReturn2() {
        _this._logLayerParameterExposure(key);
        return val;
      };
      if (typeGuard) {
        return typeGuard(val) ? logAndReturn() : defaultValue;
      }
      if (defaultValue == null) {
        return logAndReturn();
      }
      if (_typeof(val) === _typeof(defaultValue) && Array.isArray(defaultValue) === Array.isArray(val)) {
        return logAndReturn();
      }
      return defaultValue;
    }
  }, {
    key: "getValue",
    value: function getValue(key, defaultValue) {
      if (defaultValue == void 0) {
        defaultValue = null;
      }
      var val = this._value[key];
      if (val != null) {
        this._logLayerParameterExposure(key);
      }
      return val !== null && val !== void 0 ? val : defaultValue;
    }
  }, {
    key: "_logLayerParameterExposure",
    value: function _logLayerParameterExposure(parameterName) {
      var _this$_logParameterFu;
      (_this$_logParameterFu = this._logParameterFunction) === null || _this$_logParameterFu === void 0 || _this$_logParameterFu.call(this, this, parameterName);
    }
  }], [{
    key: "fromLayer",
    value: function fromLayer(layer) {
      var _layer$__evaluation$s, _layer$__evaluation, _layer$__evaluation$u, _layer$__evaluation2, _layer$__evaluation3, _layer$__evaluation4;
      var value = new Layer2(layer.name, layer.__value, layer.ruleID, migrateEvaluationDetails(layer.details), function(_layer, parameterName) {
        return layer.get(parameterName);
      }, migrateSecondaryExposures((_layer$__evaluation$s = (_layer$__evaluation = layer.__evaluation) === null || _layer$__evaluation === void 0 ? void 0 : _layer$__evaluation.secondary_exposures) !== null && _layer$__evaluation$s !== void 0 ? _layer$__evaluation$s : []), migrateSecondaryExposures((_layer$__evaluation$u = (_layer$__evaluation2 = layer.__evaluation) === null || _layer$__evaluation2 === void 0 ? void 0 : _layer$__evaluation2.undelegated_secondary_exposures) !== null && _layer$__evaluation$u !== void 0 ? _layer$__evaluation$u : []), (_layer$__evaluation3 = layer.__evaluation) === null || _layer$__evaluation3 === void 0 ? void 0 : _layer$__evaluation3.allocated_experiment_name, (_layer$__evaluation4 = layer.__evaluation) === null || _layer$__evaluation4 === void 0 ? void 0 : _layer$__evaluation4.explicit_parameters);
      return value;
    }
    /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
    /** @deprecated - do not use, this is still exported for backwards compatibility but will be removed in the next major version  */
  }]);
}();

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/Fetcher.js
var import_regenerator = __toESM(require_regenerator());

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/version.js
var CLIENT_VERSION = "0.0.0-development";

// node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct2() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct2 = function _isNativeReflectConstruct5() {
    return !!t;
  })();
}

// node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct2()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}

// node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t2)) return r.get(t2);
      r.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/errors.js
function _callSuper2(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct3() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct3() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct3 = function _isNativeReflectConstruct5() {
    return !!t;
  })();
}
var ResponseError = function(_Error) {
  function ResponseError2(message) {
    _classCallCheck(this, ResponseError2);
    return _callSuper2(this, ResponseError2, [message]);
  }
  _inherits(ResponseError2, _Error);
  return _createClass(ResponseError2);
}(_wrapNativeSuper(Error));

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/fetcher/Fetcher.js
function ownKeys5(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread5(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys5(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var DEFAULT_REQUEST_TIMEOUT_MS = 5e3;
var PROD_BASE_URL = "https://api.atlassian.com/flags";
var STAGING_BASE_URL = "https://api.stg.atlassian.com/flags";
var DEV_BASE_URL = "https://api.dev.atlassian.com/flags";
var FEDM_STAGING_BASE_URL = "https://api.stg.atlassian-us-gov-mod.com/flags";
var FEDM_PROD_BASE_URL = "https://api.atlassian-us-gov-mod.com/flags";
var IC_FFS_BASE_URL = "https://atlassian-statsig-proxy-archetype.atl-paas.%s.atl-ic.net";
var IC_STAGING_BASE_DOMAIN_URL = "oasis-stg.com/flags";
var IC_PROD_BASE_DOMAIN_URL = "atlassian-isolated.net/flags";
var GATEWAY_BASE_URL = "/gateway/api/flags";
var Fetcher = function() {
  function Fetcher2() {
    _classCallCheck(this, Fetcher2);
  }
  return _createClass(Fetcher2, null, [{
    key: "fetchClientSdk",
    value: function() {
      var _fetchClientSdk = _asyncToGenerator(import_regenerator.default.mark(function _callee(fetcherOptions) {
        var targetApp, url;
        return import_regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              targetApp = fetcherOptions.targetApp;
              url = "/api/v2/frontend/clientSdkKey/".concat(targetApp);
              _context.prev = 2;
              _context.next = 5;
              return this.fetchRequest(url, "GET", fetcherOptions);
            case 5:
              return _context.abrupt("return", _context.sent);
            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](2);
              if (!(_context.t0 instanceof Error)) {
                _context.next = 12;
                break;
              }
              throw _context.t0;
            case 12:
              throw Error("Failed to retrieve client sdk key");
            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[2, 8]]);
      }));
      function fetchClientSdk(_x) {
        return _fetchClientSdk.apply(this, arguments);
      }
      return fetchClientSdk;
    }()
  }, {
    key: "fetchExperimentValues",
    value: function() {
      var _fetchExperimentValues = _asyncToGenerator(import_regenerator.default.mark(function _callee2(fetcherOptions, identifiers, customAttributes) {
        var requestBody;
        return import_regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              requestBody = {
                identifiers,
                customAttributes,
                targetApp: fetcherOptions.targetApp
              };
              _context2.prev = 1;
              _context2.next = 4;
              return this.fetchRequest("/api/v2/frontend/experimentValues", "POST", fetcherOptions, requestBody);
            case 4:
              return _context2.abrupt("return", _context2.sent);
            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2["catch"](1);
              if (!(_context2.t0 instanceof Error)) {
                _context2.next = 11;
                break;
              }
              throw _context2.t0;
            case 11:
              throw Error("Failed to retrieve experiment values");
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[1, 7]]);
      }));
      function fetchExperimentValues(_x2, _x3, _x4) {
        return _fetchExperimentValues.apply(this, arguments);
      }
      return fetchExperimentValues;
    }()
  }, {
    key: "handleResponseError",
    value: function() {
      var _handleResponseError = _asyncToGenerator(import_regenerator.default.mark(function _callee3(response) {
        var body;
        return import_regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (response.ok) {
                _context3.next = 5;
                break;
              }
              _context3.next = 3;
              return response.text();
            case 3:
              body = _context3.sent;
              throw new ResponseError("Non 2xx response status received, status: ".concat(response.status, ", body: ").concat(JSON.stringify(body)));
            case 5:
              if (!(response.status === 204)) {
                _context3.next = 7;
                break;
              }
              throw new ResponseError("Unexpected 204 response");
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function handleResponseError(_x5) {
        return _handleResponseError.apply(this, arguments);
      }
      return handleResponseError;
    }()
  }, {
    key: "extractResponseBody",
    value: function() {
      var _extractResponseBody = _asyncToGenerator(import_regenerator.default.mark(function _callee4(response) {
        var value;
        return import_regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return response.text();
            case 2:
              value = _context4.sent;
              return _context4.abrupt("return", JSON.parse(value));
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function extractResponseBody(_x6) {
        return _extractResponseBody.apply(this, arguments);
      }
      return extractResponseBody;
    }()
  }, {
    key: "getBaseUrl",
    value: function getBaseUrl(serviceEnv) {
      var useGatewayUrl = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var perimeter = arguments.length > 2 ? arguments[2] : void 0;
      var isolationContextId2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (useGatewayUrl) {
        return GATEWAY_BASE_URL;
      }
      if (perimeter === PerimeterType.FEDRAMP_MODERATE) {
        switch (serviceEnv) {
          case FeatureGateEnvironment.Production:
            return FEDM_PROD_BASE_URL;
          case FeatureGateEnvironment.Staging:
            return FEDM_STAGING_BASE_URL;
          default:
            throw new Error('Invalid environment "'.concat(serviceEnv, '" for "').concat(perimeter, '" perimeter'));
        }
      } else if (perimeter === PerimeterType.COMMERCIAL) {
        switch (serviceEnv) {
          case FeatureGateEnvironment.Development:
            return DEV_BASE_URL;
          case FeatureGateEnvironment.Staging:
            var apiUrl = this.getApiUrl(isolationContextId2);
            if (apiUrl !== null) {
              return apiUrl;
            }
            return STAGING_BASE_URL;
          default:
            var prodApiUrl = this.getApiUrl(isolationContextId2);
            if (prodApiUrl !== null) {
              return prodApiUrl;
            }
            return PROD_BASE_URL;
        }
      } else {
        throw new Error('Invalid perimeter "'.concat(perimeter, '"'));
      }
    }
  }, {
    key: "fetchRequest",
    value: function() {
      var _fetchRequest = _asyncToGenerator(import_regenerator.default.mark(function _callee5(path, method, fetcherOptions, body) {
        var baseUrl, fetchTimeout, abortSignal, abortController, response;
        return import_regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              baseUrl = Fetcher2.getBaseUrl(fetcherOptions.environment, fetcherOptions.useGatewayURL, fetcherOptions.perimeter, fetcherOptions.isolationContextId);
              fetchTimeout = fetcherOptions.fetchTimeoutMs || DEFAULT_REQUEST_TIMEOUT_MS;
              if (AbortSignal.timeout) {
                abortSignal = AbortSignal.timeout(fetchTimeout);
              } else if (AbortController) {
                abortController = new AbortController();
                abortSignal = abortController.signal;
                setTimeout(function() {
                  return abortController.abort();
                }, fetchTimeout);
              }
              _context5.next = 5;
              return fetch("".concat(baseUrl).concat(path), _objectSpread5({
                method,
                headers: {
                  "Content-Type": "application/json",
                  "X-Client-Name": "feature-gate-js-client",
                  "X-Client-Version": CLIENT_VERSION,
                  "X-API-KEY": fetcherOptions.apiKey
                },
                signal: abortSignal
              }, body && {
                body: JSON.stringify(body)
              }));
            case 5:
              response = _context5.sent;
              _context5.next = 8;
              return this.handleResponseError(response);
            case 8:
              _context5.next = 10;
              return this.extractResponseBody(response);
            case 10:
              return _context5.abrupt("return", _context5.sent);
            case 11:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function fetchRequest(_x7, _x8, _x9, _x0) {
        return _fetchRequest.apply(this, arguments);
      }
      return fetchRequest;
    }()
  }, {
    key: "getApiUrl",
    value: function getApiUrl(isolationContextId2) {
      var window2 = this.getWindowLocation();
      if (window2 === void 0) {
        if (!isolationContextId2) {
          return null;
        }
        return IC_FFS_BASE_URL.replace("%s", isolationContextId2);
      }
      var protocol = window2.protocol, hostname = window2.hostname;
      var oasisMatch = hostname.match(/([^.]+)\.oasis-stg\.com$/);
      if (oasisMatch) {
        return "".concat(protocol, "//api.").concat(oasisMatch[1], ".").concat(IC_STAGING_BASE_DOMAIN_URL);
      }
      var isolatedMatch = hostname.match(/([^.]+)\.atlassian-isolated\.net$/);
      if (isolatedMatch) {
        return "".concat(protocol, "//api.").concat(isolatedMatch[1], ".").concat(IC_PROD_BASE_DOMAIN_URL);
      }
      return null;
    }
  }, {
    key: "getWindowLocation",
    value: function getWindowLocation() {
      if (typeof window !== "undefined" && window.location) {
        return window.location;
      }
      return void 0;
    }
  }]);
}();

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/NoFetchDataAdapter.js
var import_regenerator2 = __toESM(require_regenerator());
var import_js_client = __toESM(require_src2());
function ownKeys6(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread6(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _callSuper3(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct4() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _isNativeReflectConstruct4() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct4 = function _isNativeReflectConstruct5() {
    return !!t;
  })();
}
function _superPropGet2(t, o, e, r) {
  var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function(t2) {
    return p.apply(e, t2);
  } : p;
}
var NoFetchDataAdapter = function(_DataAdapterCore) {
  function NoFetchDataAdapter2() {
    var _this;
    _classCallCheck(this, NoFetchDataAdapter2);
    _this = _callSuper3(this, NoFetchDataAdapter2, ["NoFetchDataAdapter", "nofetch"]);
    _defineProperty(_this, "bootstrapResult", null);
    return _this;
  }
  _inherits(NoFetchDataAdapter2, _DataAdapterCore);
  return _createClass(NoFetchDataAdapter2, [{
    key: "setBootstrapData",
    value: function setBootstrapData(data) {
      this.bootstrapResult = data ? {
        source: "Bootstrap",
        data: JSON.stringify(data),
        receivedAt: Date.now(),
        stableID: import_js_client.StableID.get(this._getSdkKey()),
        fullUserHash: null
      } : null;
    }
  }, {
    key: "prefetchData",
    value: function() {
      var _prefetchData = _asyncToGenerator(import_regenerator2.default.mark(function _callee(_user, _options) {
        return import_regenerator2.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function prefetchData(_x, _x2) {
        return _prefetchData.apply(this, arguments);
      }
      return prefetchData;
    }()
  }, {
    key: "getDataAsync",
    value: function() {
      var _getDataAsync = _asyncToGenerator(import_regenerator2.default.mark(function _callee2(_current, user, _options) {
        return import_regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", this.bootstrapResult && _objectSpread6(_objectSpread6({}, this.bootstrapResult), {}, {
                fullUserHash: (0, import_js_client._getFullUserHash)(user)
              }));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getDataAsync(_x3, _x4, _x5) {
        return _getDataAsync.apply(this, arguments);
      }
      return getDataAsync;
    }()
  }, {
    key: "getDataSync",
    value: function getDataSync(user) {
      return this.bootstrapResult && _objectSpread6(_objectSpread6({}, this.bootstrapResult), {}, {
        fullUserHash: (0, import_js_client._getFullUserHash)(user)
      });
    }
  }, {
    key: "_fetchFromNetwork",
    value: function() {
      var _fetchFromNetwork2 = _asyncToGenerator(import_regenerator2.default.mark(function _callee3(_current, _user, _options) {
        return import_regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", null);
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function _fetchFromNetwork(_x6, _x7, _x8) {
        return _fetchFromNetwork2.apply(this, arguments);
      }
      return _fetchFromNetwork;
    }()
  }, {
    key: "_getCacheKey",
    value: function _getCacheKey(user) {
      var key = (0, import_js_client._getStorageKey)(this._getSdkKey(), user);
      return "".concat(import_js_client.DataAdapterCachePrefix, ".").concat(this._cacheSuffix, ".").concat(key);
    }
  }, {
    key: "_isCachedResultValidFor204",
    value: function _isCachedResultValidFor204(_result, _user) {
      return false;
    }
  }, {
    key: "setDataLegacy",
    value: function setDataLegacy(data, user) {
      _superPropGet2(NoFetchDataAdapter2, "setData", this, 3)([data, user]);
    }
    // Do not stringify options property since that includes this adapter and will
    // cause a circular reference when Statsig sends diagnostic events and including
    // values is not necessary and makes the result huge
  }, {
    key: "toJSON",
    value: function toJSON() {
      var result = _objectSpread6({}, this);
      delete result._options;
      delete result._inMemoryCache;
      delete result.bootstrapResult;
      return result;
    }
  }]);
}(import_js_client.DataAdapterCore);

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/PersistentOverrideAdapter.js
var import_client_core = __toESM(require_src());
function ownKeys7(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread7(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys7(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys7(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray2(r)) || e && r && "number" == typeof r.length) {
      t && (r = t);
      var _n = 0, F = function F2() {
      };
      return { s: F, n: function n() {
        return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
      }, e: function e2(r2) {
        throw r2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u = false;
  return { s: function s() {
    t = t.call(r);
  }, n: function n() {
    var r2 = t.next();
    return a = r2.done, r2;
  }, e: function e2(r2) {
    u = true, o = r2;
  }, f: function f() {
    try {
      a || null == t.return || t.return();
    } finally {
      if (u) throw o;
    }
  } };
}
function _unsupportedIterableToArray2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
  }
}
function _arrayLikeToArray2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
var LOCAL_OVERRIDE_REASON = "LocalOverride:Recognized";
var LOCAL_STORAGE_KEY = "STATSIG_OVERRIDES";
var LEGACY_LOCAL_STORAGE_KEY = "STATSIG_JS_LITE_LOCAL_OVERRIDES";
var makeEmptyStore = function makeEmptyStore2() {
  return {
    gates: {},
    configs: {},
    layers: {}
  };
};
var djb2MapKey = function djb2MapKey2(hash, kind) {
  return kind + ":" + hash;
};
var PersistentOverrideAdapter = function() {
  function PersistentOverrideAdapter2(localStorageKey) {
    _classCallCheck(this, PersistentOverrideAdapter2);
    this._overrides = makeEmptyStore();
    this._djb2Map = /* @__PURE__ */ new Map();
    this._localStorageKey = localStorageKey;
  }
  return _createClass(PersistentOverrideAdapter2, [{
    key: "parseStoredOverrides",
    value: function parseStoredOverrides(localStorageKey) {
      try {
        var json = window.localStorage.getItem(localStorageKey);
        if (!json) {
          return makeEmptyStore();
        }
        return JSON.parse(json);
      } catch (_unused) {
        return makeEmptyStore();
      }
    }
  }, {
    key: "mergeOverrides",
    value: function mergeOverrides() {
      var merged = makeEmptyStore();
      for (var _len = arguments.length, allOverrides = new Array(_len), _key = 0; _key < _len; _key++) {
        allOverrides[_key] = arguments[_key];
      }
      for (var _i = 0, _allOverrides = allOverrides; _i < _allOverrides.length; _i++) {
        var overrides = _allOverrides[_i];
        for (var _i2 = 0, _Object$entries = Object.entries((_overrides$gates = overrides.gates) !== null && _overrides$gates !== void 0 ? _overrides$gates : {}); _i2 < _Object$entries.length; _i2++) {
          var _overrides$gates;
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2), name = _Object$entries$_i[0], value = _Object$entries$_i[1];
          merged.gates[name] = value;
        }
        for (var _i3 = 0, _Object$entries2 = Object.entries((_overrides$configs = overrides.configs) !== null && _overrides$configs !== void 0 ? _overrides$configs : {}); _i3 < _Object$entries2.length; _i3++) {
          var _overrides$configs;
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2), _name = _Object$entries2$_i[0], _value = _Object$entries2$_i[1];
          merged.configs[_name] = _value;
        }
        for (var _i4 = 0, _Object$entries3 = Object.entries((_overrides$layers = overrides.layers) !== null && _overrides$layers !== void 0 ? _overrides$layers : {}); _i4 < _Object$entries3.length; _i4++) {
          var _overrides$layers;
          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i4], 2), _name2 = _Object$entries3$_i[0], _value2 = _Object$entries3$_i[1];
          merged.layers[_name2] = _value2;
        }
      }
      return merged;
    }
  }, {
    key: "initFromStoredOverrides",
    value: function initFromStoredOverrides() {
      var storedOverrides = this.mergeOverrides(this._overrides, this.parseStoredOverrides(LEGACY_LOCAL_STORAGE_KEY), this.parseStoredOverrides(this._localStorageKey));
      try {
        window.localStorage.removeItem(LEGACY_LOCAL_STORAGE_KEY);
      } catch (_unused2) {
      }
      for (var _i5 = 0, _Object$values = Object.values(storedOverrides); _i5 < _Object$values.length; _i5++) {
        var container = _Object$values[_i5];
        var allKeys = new Set(Object.keys(container));
        var _iterator = _createForOfIteratorHelper(allKeys), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var name = _step.value;
            var hash = (0, import_client_core._DJB2)(name);
            if (allKeys.has(hash)) {
              delete container[hash];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      this.applyOverrides(storedOverrides);
    }
  }, {
    key: "saveOverrides",
    value: function saveOverrides() {
      try {
        window.localStorage.setItem(this._localStorageKey, JSON.stringify(this._overrides));
      } catch (_unused3) {
      }
    }
  }, {
    key: "getOverrides",
    value: function getOverrides() {
      return this.mergeOverrides(this._overrides);
    }
  }, {
    key: "applyOverrides",
    value: function applyOverrides(overrides) {
      var newOverrides = _objectSpread7(_objectSpread7({}, makeEmptyStore()), overrides);
      this._djb2Map.clear();
      for (var _i6 = 0, _Object$entries4 = Object.entries(newOverrides); _i6 < _Object$entries4.length; _i6++) {
        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i6], 2), containerName = _Object$entries4$_i[0], container = _Object$entries4$_i[1];
        for (var _i7 = 0, _Object$entries5 = Object.entries(container); _i7 < _Object$entries5.length; _i7++) {
          var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i7], 2), name = _Object$entries5$_i[0], value = _Object$entries5$_i[1];
          this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), containerName), value);
        }
      }
      this._overrides = newOverrides;
    }
  }, {
    key: "setOverrides",
    value: function setOverrides(overrides) {
      this.applyOverrides(overrides);
      this.saveOverrides();
    }
  }, {
    key: "overrideGate",
    value: function overrideGate(name, value) {
      this._overrides.gates[name] = value;
      this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "gates"), value);
      this.saveOverrides();
    }
  }, {
    key: "removeGateOverride",
    value: function removeGateOverride(name) {
      delete this._overrides.gates[name];
      this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "gates"));
      this.saveOverrides();
    }
  }, {
    key: "getGateOverride",
    value: function getGateOverride(current, _user) {
      var _this$_overrides$gate;
      var overridden = (_this$_overrides$gate = this._overrides.gates[current.name]) !== null && _this$_overrides$gate !== void 0 ? _this$_overrides$gate : this._djb2Map.get(djb2MapKey(current.name, "gates"));
      if (overridden == null) {
        return null;
      }
      return _objectSpread7(_objectSpread7({}, current), {}, {
        value: overridden,
        details: _objectSpread7(_objectSpread7({}, current.details), {}, {
          reason: LOCAL_OVERRIDE_REASON
        })
      });
    }
  }, {
    key: "overrideDynamicConfig",
    value: function overrideDynamicConfig(name, value) {
      this._overrides.configs[name] = value;
      this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "configs"), value);
      this.saveOverrides();
    }
  }, {
    key: "removeDynamicConfigOverride",
    value: function removeDynamicConfigOverride(name) {
      delete this._overrides.configs[name];
      this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "configs"));
      this.saveOverrides();
    }
  }, {
    key: "getDynamicConfigOverride",
    value: function getDynamicConfigOverride(current, _user) {
      return this._getConfigOverride(current, this._overrides.configs);
    }
  }, {
    key: "overrideExperiment",
    value: function overrideExperiment(name, value) {
      this._overrides.configs[name] = value;
      this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "configs"), value);
      this.saveOverrides();
    }
  }, {
    key: "removeExperimentOverride",
    value: function removeExperimentOverride(name) {
      delete this._overrides.configs[name];
      this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "configs"));
      this.saveOverrides();
    }
  }, {
    key: "getExperimentOverride",
    value: function getExperimentOverride(current, _user) {
      return this._getConfigOverride(current, this._overrides.configs);
    }
  }, {
    key: "overrideLayer",
    value: function overrideLayer(name, value) {
      this._overrides.layers[name] = value;
      this._djb2Map.set(djb2MapKey((0, import_client_core._DJB2)(name), "layers"), value);
      this.saveOverrides();
    }
  }, {
    key: "removeLayerOverride",
    value: function removeLayerOverride(name) {
      delete this._overrides.layers[name];
      this._djb2Map.delete(djb2MapKey((0, import_client_core._DJB2)(name), "layers"));
      this.saveOverrides();
    }
  }, {
    key: "removeAllOverrides",
    value: function removeAllOverrides() {
      this._overrides = makeEmptyStore();
      try {
        window.localStorage.removeItem(this._localStorageKey);
      } catch (_unused4) {
      }
    }
  }, {
    key: "getLayerOverride",
    value: function getLayerOverride(current, _user) {
      var _this$_overrides$laye;
      var overridden = (_this$_overrides$laye = this._overrides.layers[current.name]) !== null && _this$_overrides$laye !== void 0 ? _this$_overrides$laye : this._djb2Map.get(djb2MapKey(current.name, "layers"));
      if (overridden == null) {
        return null;
      }
      return _objectSpread7(_objectSpread7({}, current), {}, {
        __value: overridden,
        get: (0, import_client_core._makeTypedGet)(current.name, overridden),
        details: _objectSpread7(_objectSpread7({}, current.details), {}, {
          reason: LOCAL_OVERRIDE_REASON
        })
      });
    }
  }, {
    key: "_getConfigOverride",
    value: function _getConfigOverride(current, lookup) {
      var _lookup$current$name;
      var overridden = (_lookup$current$name = lookup[current.name]) !== null && _lookup$current$name !== void 0 ? _lookup$current$name : this._djb2Map.get(djb2MapKey(current.name, "configs"));
      if (overridden == null) {
        return null;
      }
      return _objectSpread7(_objectSpread7({}, current), {}, {
        value: overridden,
        get: (0, import_client_core._makeTypedGet)(current.name, overridden),
        details: _objectSpread7(_objectSpread7({}, current.details), {}, {
          reason: LOCAL_OVERRIDE_REASON
        })
      });
    }
  }]);
}();

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/Client.js
var _excluded2 = ["sdkKey", "environment", "updateUserCompletionCallback", "perimeter"];
function ownKeys8(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread8(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys8(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys8(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
var DEFAULT_CLIENT_KEY = "client-default-key";
var DEFAULT_EVENT_LOGGING_API = "https://xp.atlassian.com/v1/rgstr";
var Client = function() {
  function Client2() {
    var _this = this;
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$localStorageKey = _ref.localStorageKey, localStorageKey = _ref$localStorageKey === void 0 ? LOCAL_STORAGE_KEY : _ref$localStorageKey, overrideAdapter = _ref.overrideAdapter;
    _classCallCheck(this, Client2);
    _defineProperty(this, "initPromise", null);
    _defineProperty(this, "initCompleted", false);
    _defineProperty(this, "initWithDefaults", false);
    _defineProperty(this, "hasCheckGateErrorOccurred", false);
    _defineProperty(this, "hasGetExperimentErrorOccurred", false);
    _defineProperty(this, "hasGetExperimentValueErrorOccurred", false);
    _defineProperty(this, "hasGetLayerErrorOccurred", false);
    _defineProperty(this, "hasGetLayerValueErrorOccurred", false);
    _defineProperty(this, "subscriptions", new Subscriptions());
    _defineProperty(this, "dataAdapter", new NoFetchDataAdapter());
    _defineProperty(this, "statsigValuesUpdated", function() {
      if (_this.user) {
        _this.statsigClient.updateUserSync(_this.user, {
          disableBackgroundCacheRefresh: true
        });
      }
      _this.subscriptions.anyUpdated();
    });
    this.overrideAdapter = overrideAdapter || new PersistentOverrideAdapter(localStorageKey);
  }
  return _createClass(Client2, [{
    key: "initialize",
    value: function() {
      var _initialize = _asyncToGenerator(import_regenerator3.default.mark(function _callee(clientOptions, identifiers, customAttributes) {
        var _this2 = this;
        var clientOptionsWithDefaults, startTime;
        return import_regenerator3.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
              if (!this.initPromise) {
                _context.next = 4;
                break;
              }
              if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                console.warn("Feature Gates client already initialized with different options. New options were not applied.");
              }
              return _context.abrupt("return", this.initPromise);
            case 4:
              startTime = performance.now();
              this.initOptions = clientOptionsWithDefaults;
              this.initPromise = this.init(clientOptionsWithDefaults, identifiers, customAttributes).then(function() {
                _this2.initCompleted = true;
                _this2.initWithDefaults = true;
              }).finally(function() {
                var endTime = performance.now();
                var totalTime = endTime - startTime;
                _this2.fireClientEvent(startTime, totalTime, "initialize", _this2.initCompleted, clientOptionsWithDefaults.apiKey);
              });
              return _context.abrupt("return", this.initPromise);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function initialize(_x, _x2, _x3) {
        return _initialize.apply(this, arguments);
      }
      return initialize;
    }()
  }, {
    key: "initializeWithProvider",
    value: function() {
      var _initializeWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee2(clientOptions, provider, identifiers, customAttributes) {
        var _this3 = this;
        var clientOptionsWithDefaults, startTime;
        return import_regenerator3.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
              if (!this.initPromise) {
                _context2.next = 4;
                break;
              }
              if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                console.warn("Feature Gates client already initialized with different options. New options were not applied.");
              }
              return _context2.abrupt("return", this.initPromise);
            case 4:
              startTime = performance.now();
              this.initOptions = clientOptionsWithDefaults;
              this.provider = provider;
              this.provider.setClientVersion(CLIENT_VERSION);
              if (this.provider.setApplyUpdateCallback) {
                this.provider.setApplyUpdateCallback(this.applyUpdateCallback.bind(this));
              }
              this.initPromise = this.initWithProvider(clientOptionsWithDefaults, provider, identifiers, customAttributes).then(function() {
                _this3.initCompleted = true;
                _this3.initWithDefaults = true;
              }).finally(function() {
                var endTime = performance.now();
                var totalTime = endTime - startTime;
                _this3.fireClientEvent(startTime, totalTime, "initializeWithProvider", _this3.initCompleted, provider.getApiKey ? provider.getApiKey() : void 0);
              });
              return _context2.abrupt("return", this.initPromise);
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function initializeWithProvider(_x4, _x5, _x6, _x7) {
        return _initializeWithProvider.apply(this, arguments);
      }
      return initializeWithProvider;
    }()
  }, {
    key: "applyUpdateCallback",
    value: function applyUpdateCallback(experimentsResult) {
      try {
        if (this.initCompleted || this.initWithDefaults) {
          this.assertInitialized(this.statsigClient);
          this.dataAdapter.setBootstrapData(experimentsResult.experimentValues);
          this.dataAdapter.setData(JSON.stringify(experimentsResult.experimentValues));
          this.statsigValuesUpdated();
        }
      } catch (error) {
        console.warn("Error when attempting to apply update", error);
      }
    }
  }, {
    key: "fireClientEvent",
    value: function fireClientEvent(startTime, totalTime, action, success) {
      var _analyticsWebClient, _this4 = this;
      var apiKey = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
      (_analyticsWebClient = this.initOptions.analyticsWebClient) === null || _analyticsWebClient === void 0 || _analyticsWebClient.then(function(analyticsWebClient) {
        var attributes = _objectSpread8({
          targetApp: _this4.initOptions.targetApp,
          clientVersion: CLIENT_VERSION,
          success,
          startTime,
          totalTime
        }, apiKey && {
          apiKey
        });
        analyticsWebClient.sendOperationalEvent({
          action,
          actionSubject: "featureGatesClient",
          attributes,
          tags: ["measurement"],
          source: "@atlaskit/feature-gate-js-client"
        });
      }).catch(function(err) {
        if (_this4.initOptions.environment !== FeatureGateEnvironment.Production) {
          console.error("Analytics web client promise did not resolve", err);
        }
      });
    }
  }, {
    key: "initializeFromValues",
    value: function() {
      var _initializeFromValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee3(clientOptions, identifiers, customAttributes) {
        var _this5 = this;
        var initializeValues, clientOptionsWithDefaults, startTime, _args3 = arguments;
        return import_regenerator3.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              initializeValues = _args3.length > 3 && _args3[3] !== void 0 ? _args3[3] : {};
              clientOptionsWithDefaults = getOptionsWithDefaults(clientOptions);
              if (!this.initPromise) {
                _context3.next = 5;
                break;
              }
              if (!shallowEquals(clientOptionsWithDefaults, this.initOptions)) {
                console.warn("Feature Gates client already initialized with different options. New options were not applied.");
              }
              return _context3.abrupt("return", this.initPromise);
            case 5:
              if (!Object.prototype.hasOwnProperty.call(initializeValues, "has_updates")) {
                initializeValues["has_updates"] = true;
              }
              startTime = performance.now();
              this.initOptions = clientOptionsWithDefaults;
              this.initPromise = this.initFromValues(clientOptionsWithDefaults, identifiers, customAttributes, initializeValues).then(function() {
                _this5.initCompleted = true;
                _this5.initWithDefaults = true;
              }).finally(function() {
                var endTime = performance.now();
                var totalTime = endTime - startTime;
                _this5.fireClientEvent(startTime, totalTime, "initializeFromValues", _this5.initCompleted);
              });
              return _context3.abrupt("return", this.initPromise);
            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function initializeFromValues(_x8, _x9, _x0) {
        return _initializeFromValues.apply(this, arguments);
      }
      return initializeFromValues;
    }()
  }, {
    key: "assertInitialized",
    value: function assertInitialized(statsigClient) {
      if (!statsigClient) {
        throw new Error("Client must be initialized before using this method");
      }
    }
    /**
     * This method updates the user using a network call to fetch the new set of values.
     * @param fetchOptions {FetcherOptions}
     * @param identifiers {Identifiers}
     * @param customAttributes {CustomAttributes}
     */
  }, {
    key: "updateUser",
    value: function() {
      var _updateUser = _asyncToGenerator(import_regenerator3.default.mark(function _callee4(fetchOptions, identifiers, customAttributes) {
        var fetchOptionsWithDefaults, initializeValuesProducer;
        return import_regenerator3.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              this.assertInitialized(this.statsigClient);
              fetchOptionsWithDefaults = getOptionsWithDefaults(fetchOptions);
              initializeValuesProducer = function initializeValuesProducer2() {
                return Fetcher.fetchExperimentValues(fetchOptionsWithDefaults, identifiers, customAttributes).then(function(_ref2) {
                  var experimentValues = _ref2.experimentValues, customAttributes2 = _ref2.customAttributes;
                  return {
                    experimentValues,
                    customAttributesFromFetch: customAttributes2
                  };
                });
              };
              _context4.next = 5;
              return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function updateUser(_x1, _x10, _x11) {
        return _updateUser.apply(this, arguments);
      }
      return updateUser;
    }()
  }, {
    key: "updateUserWithProvider",
    value: function() {
      var _updateUserWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee5(identifiers, customAttributes) {
        var _this6 = this;
        return import_regenerator3.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              this.assertInitialized(this.statsigClient);
              if (this.provider) {
                _context5.next = 3;
                break;
              }
              throw new Error("Cannot update user using provider as the client was not initialised with a provider");
            case 3:
              _context5.next = 5;
              return this.provider.setProfile(this.initOptions, identifiers, customAttributes);
            case 5:
              _context5.next = 7;
              return this.updateUserUsingInitializeValuesProducer(function() {
                return _this6.provider.getExperimentValues();
              }, identifiers, customAttributes);
            case 7:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function updateUserWithProvider(_x12, _x13) {
        return _updateUserWithProvider.apply(this, arguments);
      }
      return updateUserWithProvider;
    }()
  }, {
    key: "updateUserWithValues",
    value: function() {
      var _updateUserWithValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee6(identifiers, customAttributes) {
        var initializeValues, initializeValuesProducer, _args6 = arguments;
        return import_regenerator3.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              initializeValues = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : {};
              this.assertInitialized(this.statsigClient);
              initializeValuesProducer = function initializeValuesProducer2() {
                return Promise.resolve({
                  experimentValues: initializeValues,
                  customAttributesFromFetch: customAttributes
                });
              };
              _context6.next = 5;
              return this.updateUserUsingInitializeValuesProducer(initializeValuesProducer, identifiers, customAttributes);
            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function updateUserWithValues(_x14, _x15) {
        return _updateUserWithValues.apply(this, arguments);
      }
      return updateUserWithValues;
    }()
  }, {
    key: "initializeCalled",
    value: function initializeCalled() {
      return this.initPromise != null;
    }
  }, {
    key: "initializeCompleted",
    value: function initializeCompleted() {
      return this.initCompleted;
    }
  }, {
    key: "waitUntilInitializeCompleted",
    value: function() {
      var _waitUntilInitializeCompleted = _asyncToGenerator(import_regenerator3.default.mark(function _callee7() {
        return import_regenerator3.default.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (this.initPromise) {
                _context7.next = 2;
                break;
              }
              throw new Error("The client must be initialized before you can wait until initialized.");
            case 2:
              if (!this.initCompleted) {
                _context7.next = 4;
                break;
              }
              return _context7.abrupt("return");
            case 4:
              _context7.next = 6;
              return this.initPromise;
            case 6:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function waitUntilInitializeCompleted() {
        return _waitUntilInitializeCompleted.apply(this, arguments);
      }
      return waitUntilInitializeCompleted;
    }()
    /**
     * Returns the value for a feature gate. Returns false if there are errors.
     * @param {string} gateName - The name of the feature gate.
     * @param {Object} options
     * @param {boolean} options.fireGateExposure
     *        Whether or not to fire the exposure event for the gate. Defaults to true.
     *        To log an exposure event manually at a later time, use {@link Client.manuallyLogGateExposure}
     *        (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
     */
  }, {
    key: "checkGate",
    value: function checkGate(gateName) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      try {
        this.assertInitialized(this.statsigClient);
        var _options$fireGateExpo = options.fireGateExposure, fireGateExposure = _options$fireGateExpo === void 0 ? true : _options$fireGateExpo;
        return this.statsigClient.checkGate(gateName, {
          disableExposureLog: !fireGateExposure
        });
      } catch (error) {
        if (!this.hasCheckGateErrorOccurred) {
          console.warn({
            msg: "An error has occurred checking the feature gate. Only the first occurrence of this error is logged.",
            gateName,
            error
          });
          this.hasCheckGateErrorOccurred = true;
        }
        return false;
      }
    }
  }, {
    key: "isGateExist",
    value: function isGateExist(gateName) {
      try {
        this.assertInitialized(this.statsigClient);
        var gate = this.statsigClient.getFeatureGate(gateName, {
          disableExposureLog: true
        });
        return !gate.details.reason.includes("Unrecognized");
      } catch (error) {
        console.error("Error occurred when trying to check FeatureGate: ".concat(error));
        return true;
      }
    }
  }, {
    key: "isExperimentExist",
    value: function isExperimentExist(experimentName) {
      try {
        this.assertInitialized(this.statsigClient);
        var config = this.statsigClient.getExperiment(experimentName, {
          disableExposureLog: true
        });
        return !config.details.reason.includes("Unrecognized");
      } catch (error) {
        console.error("Error occurred when trying to check Experiment: ".concat(error));
        return true;
      }
    }
    /**
     * Manually log a gate exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
     * This is useful if you have evaluated a gate earlier via {@link Client.checkGate} where
     * <code>options.fireGateExposure</code> is false.
     * @param gateName
     */
  }, {
    key: "manuallyLogGateExposure",
    value: function manuallyLogGateExposure(gateName) {
      this.assertInitialized(this.statsigClient);
      this.statsigClient.checkGate(gateName);
    }
    /**
     * Returns the entire config for a given experiment.
     *
     * @param {string} experimentName - The name of the experiment
     * @param {Object} options
     * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
     * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
     * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
     * @returns The config for an experiment
     * @example
     * ```ts
     * const experimentConfig = client.getExperiment('example-experiment-name');
     * const backgroundColor: string = experimentConfig.get('backgroundColor', 'yellow');
     * ```
     */
  }, {
    key: "getExperiment",
    value: function getExperiment(experimentName) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      try {
        this.assertInitialized(this.statsigClient);
        var _options$fireExperime = options.fireExperimentExposure, fireExperimentExposure = _options$fireExperime === void 0 ? true : _options$fireExperime;
        return DynamicConfig.fromExperiment(this.statsigClient.getExperiment(experimentName, {
          disableExposureLog: !fireExperimentExposure
        }));
      } catch (error) {
        if (!this.hasGetExperimentErrorOccurred) {
          console.warn({
            msg: "An error has occurred getting the experiment. Only the first occurrence of this error is logged.",
            experimentName,
            error
          });
          this.hasGetExperimentErrorOccurred = true;
        }
        return new DynamicConfig(experimentName, {}, "", {
          time: Date.now(),
          reason: EvaluationReason.Error
        });
      }
    }
    /**
     * Returns the value of a given parameter in an experiment config.
     *
     * @template T
     * @param {string} experimentName - The name of the experiment
     * @param {string} parameterName - The name of the parameter to fetch from the experiment config
     * @param {T} defaultValue - The value to serve if the experiment or parameter do not exist, or
     * if the returned value does not match the expected type.
     * @param {Object} options
     * @param {boolean} options.fireExperimentExposure - Whether or not to fire the exposure event
     * for the experiment. Defaults to true. To log an exposure event manually at a later time, use
     * {@link Client.manuallyLogExperimentExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
     * @param {function} options.typeGuard - A function that asserts that the return value has the
     * expected type. If this function returns false, then the default value will be returned
     * instead. This can be set to protect your code from unexpected values being set remotely. By
     * default, this will be done by asserting that the default value and value are the same primitive
     * type.
     * @returns The value of the parameter if the experiment and parameter both exist, otherwise the
     * default value.
     * @example
     ``` ts
     type ValidColor = 'blue' | 'red' | 'yellow';
     type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
    	 const isValidColor: ValidColorTypeCheck =
    		(value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
    	 const buttonColor: ValidColor = client.getExperimentValue(
    		'example-experiment-name',
    		'backgroundColor',
    		'yellow',
    		{
    				typeGuard: isValidColor
    		}
     );
     ```
    */
  }, {
    key: "getExperimentValue",
    value: function getExperimentValue(experimentName, parameterName, defaultValue) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var experiment = this.getExperiment(experimentName, options);
      try {
        var typeGuard = options.typeGuard;
        return experiment.get(parameterName, defaultValue, typeGuard);
      } catch (error) {
        if (!this.hasGetExperimentValueErrorOccurred) {
          console.warn({
            msg: "An error has occurred getting the experiment value. Only the first occurrence of this error is logged.",
            experimentName,
            defaultValue,
            options,
            error
          });
          this.hasGetExperimentValueErrorOccurred = true;
        }
        return defaultValue;
      }
    }
    /**
     * Manually log an experiment exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
     * This is useful if you have evaluated an experiment earlier via {@link Client.getExperimentValue} or
     * {@link Client.getExperiment} where <code>options.fireExperimentExposure</code> is false.
     * @param experimentName
     */
  }, {
    key: "manuallyLogExperimentExposure",
    value: function manuallyLogExperimentExposure(experimentName) {
      this.assertInitialized(this.statsigClient);
      this.statsigClient.getExperiment(experimentName);
    }
    /**
     * Manually log a layer exposure (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
     * This is useful if you have evaluated a layer earlier via {@link Client.getLayerValue} where <code>options.fireExperimentExposure</code> is false.
     * @param layerName
     * @param parameterName
     */
  }, {
    key: "manuallyLogLayerExposure",
    value: function manuallyLogLayerExposure(layerName, parameterName) {
      var _this$statsigClient$g;
      this.assertInitialized(this.statsigClient);
      (_this$statsigClient$g = this.statsigClient.getLayer(layerName)) === null || _this$statsigClient$g === void 0 || _this$statsigClient$g.get(parameterName);
    }
  }, {
    key: "shutdownStatsig",
    value: function shutdownStatsig() {
      this.assertInitialized(this.statsigClient);
      this.statsigClient.shutdown();
    }
    /**
     * Adds a new override for the given gate.
     *
     * This method is additive, meaning you can call it multiple times with different gate names to
     * build your full set of overrides.
     *
     * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
     * will continue to affect every client that is initialized on the same domain after this method
     * is called. If you are using this API for testing purposes, you should call
     * {@link Client.clearGateOverride} after your tests are completed to remove this
     * localStorage entry.
     *
     * @param {string} gateName
     * @param {boolean} value
     */
  }, {
    key: "overrideGate",
    value: function overrideGate(gateName, value) {
      this.overrideAdapter.overrideGate(gateName, value);
      if (this.user) {
        var _this$statsigClient;
        (_this$statsigClient = this.statsigClient) === null || _this$statsigClient === void 0 || _this$statsigClient.updateUserSync(this.user, {
          disableBackgroundCacheRefresh: true
        });
      }
      this.statsigValuesUpdated();
    }
    /**
     * Removes any overrides that have been set for the given gate.
     */
  }, {
    key: "clearGateOverride",
    value: function clearGateOverride(gateName) {
      this.overrideAdapter.removeGateOverride(gateName);
      this.statsigValuesUpdated();
    }
    /**
     * Adds a new override for the given config (or experiment).
     *
     * This method is additive, meaning you can call it multiple times with different experiment
     * names to build your full set of overrides.
     *
     * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
     * will continue to affect every client that is initialized on the same domain after this method
     * is called. If you are using this API for testing purposes, you should call
     * {@link Client.clearConfigOverride} after your tests are completed to remove this
     * localStorage entry.
     *
     * @param {string} experimentName
     * @param {object} values
     */
  }, {
    key: "overrideConfig",
    value: function overrideConfig(experimentName, values) {
      this.overrideAdapter.overrideDynamicConfig(experimentName, values);
      this.statsigValuesUpdated();
    }
    /**
     * Removes any overrides that have been set for the given experiment.
     * @param {string} experimentName
     */
  }, {
    key: "clearConfigOverride",
    value: function clearConfigOverride(experimentName) {
      this.overrideAdapter.removeDynamicConfigOverride(experimentName);
      this.statsigValuesUpdated();
    }
    /**
     * Set overrides for gates, experiments and layers in batch.
     *
     * Note that these overrides are **not** additive and will completely replace any that have been
     * added via prior calls to {@link Client.overrideConfig} or
     * {@link Client.overrideGate}.
     *
     * Overrides are persisted to the `STATSIG_OVERRIDES` key in localStorage, so they
     * will continue to affect every client that is initialized on the same domain after this method
     * is called. If you are using this API for testing purposes, you should call
     * {@link Client.clearAllOverrides} after your tests are completed to remove this
     * localStorage entry.
     */
  }, {
    key: "setOverrides",
    value: function setOverrides(overrides) {
      this.overrideAdapter.setOverrides(overrides);
      this.statsigValuesUpdated();
    }
    /**
     * @returns The current overrides for gates, configs (including experiments) and layers.
     */
  }, {
    key: "getOverrides",
    value: function getOverrides() {
      return this.overrideAdapter.getOverrides();
    }
    /**
     * Clears overrides for all gates, configs (including experiments) and layers.
     */
  }, {
    key: "clearAllOverrides",
    value: function clearAllOverrides() {
      this.overrideAdapter.removeAllOverrides();
      this.statsigValuesUpdated();
    }
    /**
     * Returns whether the given identifiers and customAttributes align with the current
     * set that is being used by the client.
     *
     * If this method returns false, then the {@link Client.updateUser},
     * {@link Client.updateUserWithValues} or {@link Client.updateUserWithProvider}
     * methods can be used to re-align these values.
     *
     * @param identifiers
     * @param customAttributes
     * @returns a flag indicating whether the clients current configuration aligns with the given values
     */
  }, {
    key: "isCurrentUser",
    value: function isCurrentUser(identifiers, customAttributes) {
      return shallowEquals(this.currentIdentifiers, identifiers) && shallowEquals(this.currentAttributes, customAttributes);
    }
    /**
     * Subscribe to updates where the given callback will be called with the current checkGate value
     * @param gateName
     * @param callback
     * @param options
     * @returns off function to unsubscribe from updates
     */
  }, {
    key: "onGateUpdated",
    value: function onGateUpdated(gateName, callback) {
      var _this7 = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var wrapCallback = function wrapCallback2(value) {
        var _options$fireGateExpo2 = options.fireGateExposure, fireGateExposure = _options$fireGateExpo2 === void 0 ? true : _options$fireGateExpo2;
        if (fireGateExposure) {
          _this7.manuallyLogGateExposure(gateName);
        }
        try {
          callback(value);
        } catch (error) {
          console.warn("Error calling callback for gate ".concat(gateName, " with value ").concat(value), error);
        }
      };
      return this.subscriptions.onGateUpdated(gateName, wrapCallback, this.checkGate.bind(this), options);
    }
    /**
     * Subscribe to updates where the given callback will be called with the current experiment value
     * @param experimentName
     * @param parameterName
     * @param defaultValue
     * @param callback
     * @param options
     * @returns off function to unsubscribe from updates
     */
  }, {
    key: "onExperimentValueUpdated",
    value: function onExperimentValueUpdated(experimentName, parameterName, defaultValue, callback) {
      var _this8 = this;
      var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
      var wrapCallback = function wrapCallback2(value) {
        var _options$fireExperime2 = options.fireExperimentExposure, fireExperimentExposure = _options$fireExperime2 === void 0 ? true : _options$fireExperime2;
        if (fireExperimentExposure) {
          _this8.manuallyLogExperimentExposure(experimentName);
        }
        try {
          callback(value);
        } catch (error) {
          console.warn("Error calling callback for experiment ".concat(experimentName, " with value ").concat(value), error);
        }
      };
      return this.subscriptions.onExperimentValueUpdated(experimentName, parameterName, defaultValue, wrapCallback, this.getExperimentValue.bind(this), options);
    }
    /**
     * Subscribe so on any update the callback will be called.
     * NOTE: The callback will be called whenever the values are updated even if the values have not
     * changed.
     * @param callback
     * @returns off function to unsubscribe from updates
     */
  }, {
    key: "onAnyUpdated",
    value: function onAnyUpdated(callback) {
      return this.subscriptions.onAnyUpdated(callback);
    }
    /**
     * This method initializes the client using a network call to fetch the bootstrap values for the
     * given user.
     *
     * @param clientOptions
     * @param identifiers
     * @param customAttributes
     * @private
     */
  }, {
    key: "init",
    value: function() {
      var _init = _asyncToGenerator(import_regenerator3.default.mark(function _callee8(clientOptions, identifiers, customAttributes) {
        var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all, _yield$Promise$all2, experimentValuesResult;
        return import_regenerator3.default.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              fromValuesClientOptions = _objectSpread8({}, clientOptions);
              _context8.prev = 1;
              clientSdkKeyPromise = Fetcher.fetchClientSdk(clientOptions).then(function(value) {
                return fromValuesClientOptions.sdkKey = value.clientSdkKey;
              });
              experimentValuesPromise = Fetcher.fetchExperimentValues(clientOptions, identifiers, customAttributes);
              _context8.next = 6;
              return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
            case 6:
              _yield$Promise$all = _context8.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              experimentValuesResult = _yield$Promise$all2[1];
              experimentValues = experimentValuesResult.experimentValues;
              customAttributesFromResult = experimentValuesResult.customAttributes;
              _context8.next = 20;
              break;
            case 13:
              _context8.prev = 13;
              _context8.t0 = _context8["catch"](1);
              if (_context8.t0 instanceof Error) {
                console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context8.t0 === null || _context8.t0 === void 0 ? void 0 : _context8.t0.message));
              }
              console.warn("Initialising Statsig client without values");
              _context8.next = 19;
              return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
            case 19:
              throw _context8.t0;
            case 20:
              return _context8.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
            case 21:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[1, 13]]);
      }));
      function init(_x16, _x17, _x18) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "initWithProvider",
    value: function() {
      var _initWithProvider = _asyncToGenerator(import_regenerator3.default.mark(function _callee9(baseClientOptions, provider, identifiers, customAttributes) {
        var fromValuesClientOptions, experimentValues, customAttributesFromResult, clientSdkKeyPromise, experimentValuesPromise, _yield$Promise$all3, _yield$Promise$all4, experimentValuesResult;
        return import_regenerator3.default.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              fromValuesClientOptions = _objectSpread8(_objectSpread8({}, baseClientOptions), {}, {
                disableCurrentPageLogging: true
              });
              _context9.prev = 1;
              _context9.next = 4;
              return provider.setProfile(baseClientOptions, identifiers, customAttributes);
            case 4:
              clientSdkKeyPromise = provider.getClientSdkKey().then(function(value) {
                return fromValuesClientOptions.sdkKey = value;
              });
              experimentValuesPromise = provider.getExperimentValues();
              _context9.next = 8;
              return Promise.all([clientSdkKeyPromise, experimentValuesPromise]);
            case 8:
              _yield$Promise$all3 = _context9.sent;
              _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
              experimentValuesResult = _yield$Promise$all4[1];
              experimentValues = experimentValuesResult.experimentValues;
              customAttributesFromResult = experimentValuesResult.customAttributesFromFetch;
              _context9.next = 22;
              break;
            case 15:
              _context9.prev = 15;
              _context9.t0 = _context9["catch"](1);
              if (_context9.t0 instanceof Error) {
                console.error("Error occurred when trying to fetch the Feature Gates client values, error: ".concat(_context9.t0 === null || _context9.t0 === void 0 ? void 0 : _context9.t0.message));
              }
              console.warn("Initialising Statsig client without values");
              _context9.next = 21;
              return this.initFromValues(fromValuesClientOptions, identifiers, customAttributes);
            case 21:
              throw _context9.t0;
            case 22:
              return _context9.abrupt("return", this.initFromValues(fromValuesClientOptions, identifiers, customAttributesFromResult, experimentValues));
            case 23:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[1, 15]]);
      }));
      function initWithProvider(_x19, _x20, _x21, _x22) {
        return _initWithProvider.apply(this, arguments);
      }
      return initWithProvider;
    }()
    /**
     * This method initializes the client using a set of boostrap values obtained from one of the
     * server-side SDKs.
     *
     * @param clientOptions
     * @param identifiers
     * @param customAttributes
     * @param initializeValues
     * @private
     */
  }, {
    key: "initFromValues",
    value: function() {
      var _initFromValues = _asyncToGenerator(import_regenerator3.default.mark(function _callee0(clientOptions, identifiers, customAttributes) {
        var _newClientOptions$net;
        var initializeValues, newClientOptions, sdkKey, environment, _updateUserCompletionCallback, _perimeter, restClientOptions, statsigOptions, _args0 = arguments;
        return import_regenerator3.default.wrap(function _callee0$(_context0) {
          while (1) switch (_context0.prev = _context0.next) {
            case 0:
              initializeValues = _args0.length > 3 && _args0[3] !== void 0 ? _args0[3] : {};
              this.overrideAdapter.initFromStoredOverrides();
              this.currentIdentifiers = identifiers;
              this.currentAttributes = customAttributes;
              newClientOptions = migrateInitializationOptions(clientOptions);
              if (!newClientOptions.sdkKey) {
                newClientOptions.sdkKey = DEFAULT_CLIENT_KEY;
              }
              if (!((_newClientOptions$net = newClientOptions.networkConfig) !== null && _newClientOptions$net !== void 0 && _newClientOptions$net.logEventUrl)) {
                newClientOptions.networkConfig = _objectSpread8(_objectSpread8({}, newClientOptions.networkConfig), {}, {
                  logEventUrl: DEFAULT_EVENT_LOGGING_API
                });
              }
              if (newClientOptions.perimeter === PerimeterType.FEDRAMP_MODERATE) {
                newClientOptions.disableLogging = true;
              }
              sdkKey = newClientOptions.sdkKey, environment = newClientOptions.environment, _updateUserCompletionCallback = newClientOptions.updateUserCompletionCallback, _perimeter = newClientOptions.perimeter, restClientOptions = _objectWithoutProperties(newClientOptions, _excluded2);
              this.user = toStatsigUser(identifiers, customAttributes);
              statsigOptions = _objectSpread8(_objectSpread8({}, restClientOptions), {}, {
                environment: {
                  tier: environment
                },
                includeCurrentPageUrlWithEvents: false,
                dataAdapter: this.dataAdapter,
                overrideAdapter: this.overrideAdapter,
                logEventCompressionMode: import_js_client2.LogEventCompressionMode.Forced
              });
              if (identifiers.stableId) {
                import_js_client2.StableID.setOverride(identifiers.stableId, sdkKey);
              } else {
                statsigOptions.disableStableID = true;
              }
              _context0.prev = 12;
              this.statsigClient = new import_js_client2.StatsigClient(sdkKey, this.user, statsigOptions);
              this.dataAdapter.setBootstrapData(initializeValues);
              _context0.next = 17;
              return this.statsigClient.initializeAsync();
            case 17:
              _context0.next = 29;
              break;
            case 19:
              _context0.prev = 19;
              _context0.t0 = _context0["catch"](12);
              if (_context0.t0 instanceof Error) {
                console.error("Error occurred when trying to initialise the Statsig client, error: ".concat(_context0.t0 === null || _context0.t0 === void 0 ? void 0 : _context0.t0.message));
              }
              console.warn("Initialising Statsig client with default sdk key and without values");
              this.statsigClient = new import_js_client2.StatsigClient(DEFAULT_CLIENT_KEY, this.user, statsigOptions);
              this.dataAdapter.setBootstrapData();
              _context0.next = 27;
              return this.statsigClient.initializeAsync();
            case 27:
              this.initWithDefaults = true;
              throw _context0.t0;
            case 29:
            case "end":
              return _context0.stop();
          }
        }, _callee0, this, [[12, 19]]);
      }));
      function initFromValues(_x23, _x24, _x25) {
        return _initFromValues.apply(this, arguments);
      }
      return initFromValues;
    }()
  }, {
    key: "updateUserUsingInitializeValuesProducer",
    value: function() {
      var _updateUserUsingInitializeValuesProducer = _asyncToGenerator(import_regenerator3.default.mark(function _callee10(getInitializeValues, identifiers, customAttributes) {
        var _this9 = this;
        var originalInitPromise, initializeValuesPromise, updateUserPromise;
        return import_regenerator3.default.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.assertInitialized(this.statsigClient);
              if (this.initPromise) {
                _context10.next = 3;
                break;
              }
              throw new Error("The client must be initialized before you can update the user.");
            case 3:
              if (!this.isCurrentUser(identifiers, customAttributes)) {
                _context10.next = 5;
                break;
              }
              return _context10.abrupt("return", this.initPromise);
            case 5:
              originalInitPromise = this.initPromise;
              _context10.prev = 6;
              _context10.next = 9;
              return this.initPromise;
            case 9:
              _context10.next = 13;
              break;
            case 11:
              _context10.prev = 11;
              _context10.t0 = _context10["catch"](6);
            case 13:
              initializeValuesPromise = getInitializeValues();
              updateUserPromise = this.updateStatsigClientUser(initializeValuesPromise, identifiers, customAttributes);
              this.initPromise = updateUserPromise.catch(_asyncToGenerator(import_regenerator3.default.mark(function _callee1() {
                return import_regenerator3.default.wrap(function _callee1$(_context1) {
                  while (1) switch (_context1.prev = _context1.next) {
                    case 0:
                      _this9.initPromise = originalInitPromise;
                      if (!_this9.provider) {
                        _context1.next = 4;
                        break;
                      }
                      _context1.next = 4;
                      return _this9.provider.setProfile(_this9.initOptions, _this9.currentIdentifiers, _this9.currentAttributes);
                    case 4:
                    case "end":
                      return _context1.stop();
                  }
                }, _callee1);
              })));
              return _context10.abrupt("return", updateUserPromise);
            case 17:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this, [[6, 11]]);
      }));
      function updateUserUsingInitializeValuesProducer(_x26, _x27, _x28) {
        return _updateUserUsingInitializeValuesProducer.apply(this, arguments);
      }
      return updateUserUsingInitializeValuesProducer;
    }()
  }, {
    key: "updateStatsigClientUser",
    value: function() {
      var _updateStatsigClientUser = _asyncToGenerator(import_regenerator3.default.mark(function _callee11(initializeValuesPromise, identifiers, customAttributes) {
        var _this$initOptions, _this$initOptions$upd;
        var initializeValues, user, _updateUserCompletion, _ref4, errMsg, success, errorMessage;
        return import_regenerator3.default.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.assertInitialized(this.statsigClient);
              _context11.prev = 1;
              _context11.next = 4;
              return initializeValuesPromise;
            case 4:
              initializeValues = _context11.sent;
              user = toStatsigUser(identifiers, initializeValues.customAttributesFromFetch);
              _context11.next = 13;
              break;
            case 8:
              _context11.prev = 8;
              _context11.t0 = _context11["catch"](1);
              errMsg = _context11.t0 instanceof Error ? _context11.t0.message : JSON.stringify(_context11.t0);
              (_updateUserCompletion = (_ref4 = this.initOptions).updateUserCompletionCallback) === null || _updateUserCompletion === void 0 || _updateUserCompletion.call(_ref4, false, errMsg);
              throw _context11.t0;
            case 13:
              success = true;
              errorMessage = null;
              _context11.prev = 15;
              this.dataAdapter.setBootstrapData(initializeValues.experimentValues);
              this.user = user;
              if (!this.user) {
                _context11.next = 21;
                break;
              }
              _context11.next = 21;
              return this.statsigClient.updateUserAsync(this.user);
            case 21:
              _context11.next = 27;
              break;
            case 23:
              _context11.prev = 23;
              _context11.t1 = _context11["catch"](15);
              success = false;
              errorMessage = String(_context11.t1);
            case 27:
              (_this$initOptions = this.initOptions) === null || _this$initOptions === void 0 || (_this$initOptions$upd = _this$initOptions.updateUserCompletionCallback) === null || _this$initOptions$upd === void 0 || _this$initOptions$upd.call(_this$initOptions, success, errorMessage);
              if (!success) {
                _context11.next = 34;
                break;
              }
              this.currentIdentifiers = identifiers;
              this.currentAttributes = customAttributes;
              this.subscriptions.anyUpdated();
              _context11.next = 35;
              break;
            case 34:
              throw new Error("Failed to update user. An unexpected error occured.");
            case 35:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this, [[1, 8], [15, 23]]);
      }));
      function updateStatsigClientUser(_x29, _x30, _x31) {
        return _updateStatsigClientUser.apply(this, arguments);
      }
      return updateStatsigClientUser;
    }()
  }, {
    key: "getPackageVersion",
    value: (
      /**
       * @returns string version of the current package in semver style.
       */
      function getPackageVersion() {
        return CLIENT_VERSION;
      }
    )
    /**
     * Returns a specified layer otherwise returns an empty layer as a default value if the layer doesn't exist.
     *
     * @param {string} layerName - The name of the layer
     * @param {Object} options
     * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
     * layer. Defaults to true. To log an exposure event manually at a later time, use
     * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-)).
     * @returns A layer
     * @example
     * ```ts
     * const layer = client.getLayer('example-layer-name');
     * const exampletitle: string = layer.get("title", "Welcome to Statsig!");
     * ```
     */
  }, {
    key: "getLayer",
    value: function getLayer(layerName) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      try {
        this.assertInitialized(this.statsigClient);
        var _options$fireLayerExp = options.fireLayerExposure, fireLayerExposure = _options$fireLayerExp === void 0 ? true : _options$fireLayerExp;
        return Layer.fromLayer(this.statsigClient.getLayer(layerName, {
          disableExposureLog: !fireLayerExposure
        }));
      } catch (error) {
        if (!this.hasGetLayerErrorOccurred) {
          console.warn({
            msg: "An error has occurred getting the layer. Only the first occurrence of this error is logged.",
            layerName,
            error
          });
          this.hasGetLayerErrorOccurred = true;
        }
        return Layer.fromLayer((0, import_js_client2._makeLayer)(layerName, {
          reason: "Error"
        }, null));
      }
    }
    /**
     * Returns the value of a given parameter in a layer config.
     *
     * @template T
     * @param {string} layerName - The name of the layer
     * @param {string} parameterName - The name of the parameter to fetch from the layer config
     * @param {T} defaultValue - The value to serve if the layer or parameter do not exist, or if the
     * returned value does not match the expected type.
     * @param {Object} options
     * @param {boolean} options.fireLayerExposure - Whether or not to fire the exposure event for the
     * layer. Defaults to true. To log an exposure event manually at a later time, use
     * {@link Client.manuallyLogLayerExposure} (see [Statsig docs about manually logging exposures](https://docs.statsig.com/client/jsClientSDK#manual-exposures-))
     * @param {function} options.typeGuard - A function that asserts that the return value has the expected type. If this function returns false, then the default value will be returned instead. This can be set to protect your code from unexpected values being set remotely. By default, this will be done by asserting that the default value and value are the same primitive type.
     * @returns The value of the parameter if the layer and parameter both exist, otherwise the default value.
     * @example
     * ``` ts
     * type ValidColor = 'blue' | 'red' | 'yellow';
     * type ValidColorTypeCheck = (value: unknown) => value is ValidColor;
     *
     * const isValidColor: ValidColorTypeCheck =
     *    (value: unknown) => typeof value === 'string' && ['blue', 'red', 'yellow'].includes(value);
     *
     * const buttonColor: ValidColor = client.getLayerValue(
     *    'example-layer-name',
     *    'backgroundColor',
     *    'yellow',
     *    {
     *        typeGuard: isValidColor
     *    }
     * );
     * ```
     */
  }, {
    key: "getLayerValue",
    value: function getLayerValue(layerName, parameterName, defaultValue) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var layer = this.getLayer(layerName, options);
      try {
        var typeGuard = options.typeGuard;
        return layer.get(parameterName, defaultValue, typeGuard);
      } catch (error) {
        if (!this.hasGetLayerValueErrorOccurred) {
          console.warn({
            msg: "An error has occurred getting the layer value. Only the first occurrence of this error is logged.",
            layerName,
            defaultValue,
            options,
            error
          });
          this.hasGetLayerValueErrorOccurred = true;
        }
        return defaultValue;
      }
    }
  }]);
}();

// node_modules/@atlaskit/feature-gate-js-client/dist/esm/client/FeatureGates.js
var _FeatureGates;
var FeatureGates = function() {
  function FeatureGates2() {
    _classCallCheck(this, FeatureGates2);
  }
  return _createClass(FeatureGates2, null, [{
    key: "isGateExists",
    value: function isGateExists(gateName) {
      return this.client.isGateExist(gateName);
    }
  }, {
    key: "isExperimentExists",
    value: function isExperimentExists(experimentName) {
      return this.client.isExperimentExist(experimentName);
    }
  }]);
}();
_FeatureGates = FeatureGates;
_defineProperty(FeatureGates, "client", new Client());
_defineProperty(FeatureGates, "hasCheckGateErrorOccurred", false);
_defineProperty(FeatureGates, "hasGetExperimentValueErrorOccurred", false);
_defineProperty(FeatureGates, "checkGate", function(gateName, options) {
  try {
    if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getFeatureFlagOverride === "function") {
      var overrideValue = window.__CRITERION__.getFeatureFlagOverride(gateName);
      if (overrideValue !== void 0) {
        return overrideValue;
      }
    }
  } catch (error) {
    if (!_FeatureGates.hasCheckGateErrorOccurred) {
      console.warn({
        msg: "An error has occurred checking the feature gate from criterion override. Only the first occurrence of this error is logged.",
        gateName,
        error
      });
      _FeatureGates.hasCheckGateErrorOccurred = true;
    }
  }
  return _FeatureGates.client.checkGate(gateName, options);
});
_defineProperty(FeatureGates, "getExperimentValue", function(experimentName, parameterName, defaultValue, options) {
  try {
    if (typeof window !== "undefined" && window.__CRITERION__ && typeof window.__CRITERION__.getExperimentValueOverride === "function") {
      var overrideValue = window.__CRITERION__.getExperimentValueOverride(experimentName, parameterName);
      if (overrideValue !== void 0 && overrideValue !== null) {
        return overrideValue;
      }
    }
  } catch (error) {
    if (!_FeatureGates.hasGetExperimentValueErrorOccurred) {
      console.warn({
        msg: "An error has occurred getting the experiment value from criterion override. Only the first occurrence of this error is logged.",
        experimentName,
        defaultValue,
        options,
        error
      });
      _FeatureGates.hasGetExperimentValueErrorOccurred = true;
    }
    return defaultValue;
  }
  return _FeatureGates.client.getExperimentValue(experimentName, parameterName, defaultValue, options);
});
_defineProperty(FeatureGates, "initializeCalled", _FeatureGates.client.initializeCalled.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "initializeCompleted", _FeatureGates.client.initializeCompleted.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "waitUntilInitializeCompleted", _FeatureGates.client.waitUntilInitializeCompleted.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "initialize", _FeatureGates.client.initialize.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "initializeWithProvider", _FeatureGates.client.initializeWithProvider.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "initializeFromValues", _FeatureGates.client.initializeFromValues.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "manuallyLogGateExposure", _FeatureGates.client.manuallyLogGateExposure.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "getExperiment", _FeatureGates.client.getExperiment.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "manuallyLogExperimentExposure", _FeatureGates.client.manuallyLogExperimentExposure.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "manuallyLogLayerExposure", _FeatureGates.client.manuallyLogLayerExposure.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "shutdownStatsig", _FeatureGates.client.shutdownStatsig.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "overrideGate", _FeatureGates.client.overrideGate.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "clearGateOverride", _FeatureGates.client.clearGateOverride.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "overrideConfig", _FeatureGates.client.overrideConfig.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "clearConfigOverride", _FeatureGates.client.clearConfigOverride.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "setOverrides", _FeatureGates.client.setOverrides.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "getOverrides", _FeatureGates.client.getOverrides.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "clearAllOverrides", _FeatureGates.client.clearAllOverrides.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "isCurrentUser", _FeatureGates.client.isCurrentUser.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "onGateUpdated", _FeatureGates.client.onGateUpdated.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "onExperimentValueUpdated", _FeatureGates.client.onExperimentValueUpdated.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "onAnyUpdated", _FeatureGates.client.onAnyUpdated.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "updateUser", _FeatureGates.client.updateUser.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "updateUserWithProvider", _FeatureGates.client.updateUserWithProvider.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "updateUserWithValues", _FeatureGates.client.updateUserWithValues.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "getPackageVersion", _FeatureGates.client.getPackageVersion.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "getLayer", _FeatureGates.client.getLayer.bind(_FeatureGates.client));
_defineProperty(FeatureGates, "getLayerValue", _FeatureGates.client.getLayerValue.bind(_FeatureGates.client));
var boundFGJS = FeatureGates;
if (typeof window !== "undefined") {
  if (window.__FEATUREGATES_JS__ === void 0) {
    window.__FEATUREGATES_JS__ = FeatureGates;
  } else {
    boundFGJS = window.__FEATUREGATES_JS__;
    boundVersion = ((_boundFGJS = boundFGJS) === null || _boundFGJS === void 0 || (_boundFGJS$getPackage = _boundFGJS.getPackageVersion) === null || _boundFGJS$getPackage === void 0 ? void 0 : _boundFGJS$getPackage.call(_boundFGJS)) || "4.10.0 or earlier";
    if (boundVersion !== CLIENT_VERSION) {
      message = "Multiple versions of FeatureGateClients found on the current page.\n      The currently bound version is ".concat(boundVersion, " when module version ").concat(CLIENT_VERSION, " was loading.");
      console.warn(message);
    }
  }
}
var _boundFGJS;
var _boundFGJS$getPackage;
var boundVersion;
var message;
var FeatureGates_default = boundFGJS;

// node_modules/@atlaskit/platform-feature-flags/dist/esm/debug.js
var _process;
var _process2;
var TESTS_MODE = (globalThis === null || globalThis === void 0 || (_process = globalThis.process) === null || _process === void 0 || (_process = _process.env) === null || _process === void 0 ? void 0 : _process.JEST_WORKER_ID) !== void 0;
var DEBUG_MODE = !TESTS_MODE && (globalThis === null || globalThis === void 0 || (_process2 = globalThis.process) === null || _process2 === void 0 || (_process2 = _process2.env) === null || _process2 === void 0 ? void 0 : _process2.NODE_ENV) !== "production";
var debug = function debug2() {
  var _console;
  if (!DEBUG_MODE) {
    return;
  }
  (_console = console).debug.apply(_console, arguments);
};

// node_modules/@atlaskit/platform-feature-flags/dist/esm/resolvers.js
var pkgName = "@atlaskit/platform-feature-flags";
var PFF_GLOBAL_KEY = "__PLATFORM_FEATURE_FLAGS__";
var hasProcessEnv = typeof process !== "undefined" && typeof process.env !== "undefined";
var ENV_ENABLE_PLATFORM_FF = hasProcessEnv ? (
  // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
  process.env["ENABLE_PLATFORM_FF"] === "true"
) : false;
var ENV_STORYBOOK_ENABLE_PLATFORM_FF = hasProcessEnv ? (
  // Use global "process" variable and process.env['FLAG_NAME'] syntax, so it can be replaced by webpack DefinePlugin
  process.env["STORYBOOK_ENABLE_PLATFORM_FF"] === "true"
) : false;
var ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE = ENV_ENABLE_PLATFORM_FF || ENV_STORYBOOK_ENABLE_PLATFORM_FF;
var DEFAULT_PFF_GLOBAL = {
  booleanResolver: void 0
};
var globalVar = typeof window !== "undefined" ? window : globalThis;
globalVar[PFF_GLOBAL_KEY] = globalVar[PFF_GLOBAL_KEY] || DEFAULT_PFF_GLOBAL;
function resolveBooleanFlag(flagKey) {
  if (ENABLE_GLOBAL_PLATFORM_FF_OVERRIDE) {
    debug('[%s]: The feature flags were enabled while running tests. The flag "%s" will be always enabled.', pkgName, flagKey);
    return true;
  }
  try {
    var _globalVar$PFF_GLOBAL, _globalVar$PFF_GLOBAL2, _globalVar$PFF_GLOBAL3;
    if (((_globalVar$PFF_GLOBAL = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL === void 0 ? void 0 : _globalVar$PFF_GLOBAL.booleanResolver) === void 0 || ((_globalVar$PFF_GLOBAL2 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL2 === void 0 ? void 0 : _globalVar$PFF_GLOBAL2.booleanResolver) === null) {
      return FeatureGates_default.checkGate(flagKey);
    }
    var result = (_globalVar$PFF_GLOBAL3 = globalVar[PFF_GLOBAL_KEY]) === null || _globalVar$PFF_GLOBAL3 === void 0 ? void 0 : _globalVar$PFF_GLOBAL3.booleanResolver(flagKey);
    if (typeof result !== "boolean") {
      console.warn("".concat(flagKey, " resolved to a non-boolean value, returning false for safety"));
      return false;
    }
    return result;
  } catch (e) {
    return false;
  }
}

// node_modules/@atlaskit/platform-feature-flags/dist/esm/index.js
function fg(name) {
  return resolveBooleanFlag(name);
}

// node_modules/@atlaskit/theme/dist/esm/colors.js
var R300 = "#FF5630";
var R400 = "#DE350B";
var R500 = "#BF2600";
var Y200 = "#FFC400";
var Y300 = "#FFAB00";
var Y400 = "#FF991F";
var B50 = "#DEEBFF";
var B75 = "#B3D4FF";
var B100 = "#4C9AFF";
var B200 = "#2684FF";
var B300 = "#0065FF";
var B400 = "#0052CC";
var B500 = "#0747A6";
var N0 = "#FFFFFF";
var N10 = "#FAFBFC";
var N20 = "#F4F5F7";
var N30 = "#EBECF0";
var N70 = "#A5ADBA";
var N80 = "#97A0AF";
var N90 = "#8993A4";
var N100 = "#7A869A";
var N200 = "#6B778C";
var N400 = "#505F79";
var N500 = "#42526E";
var N700 = "#253858";
var N800 = "#172B4D";
var N900 = "#091E42";
var N20A = "rgba(9, 30, 66, 0.04)";
var N30A = "rgba(9, 30, 66, 0.08)";
var DN400 = "#9FB0CC";
var DN300 = "#8C9CB8";
var DN100 = "#67758F";
var DN70 = "#3B475C";
var DN60 = "#313D52";
var DN30 = "#1B2638";
var DN0 = "#0D1424";

export {
  _extends,
  _slicedToArray,
  _objectWithoutProperties,
  ax,
  cssCustomPropertyValue,
  _toConsumableArray,
  _classCallCheck,
  _createClass,
  _possibleConstructorReturn,
  _getPrototypeOf,
  _inherits,
  esm_default,
  useAnalyticsContext,
  useTrackedRef,
  usePlatformLeafEventHandler,
  fg,
  R300,
  R400,
  R500,
  Y200,
  Y300,
  Y400,
  B50,
  B75,
  B100,
  B200,
  B300,
  B400,
  B500,
  N0,
  N10,
  N20,
  N30,
  N70,
  N80,
  N90,
  N100,
  N200,
  N400,
  N500,
  N700,
  N800,
  N900,
  N20A,
  N30A,
  DN400,
  DN300,
  DN100,
  DN70,
  DN60,
  DN30,
  DN0
};
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)
*/
//# sourceMappingURL=chunk-X2WRMYJC.js.map
